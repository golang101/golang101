<h1>Go 细节 101</h1>

<div>
<p>
这一章节将列出Go的各个方面的细节。
其中一些细节在Go 101的其它章节中也有描述。
以下部分将讨论其中一些。
</p>

<ul>
<li>
	代码包相关的细节：
	<ul>
	<li>
		<a href="#import-package-multiple-times">一个包可以在源文件里被导入多次。</a>
	</li>
	<li>
		<a href="#force-import-path">在<code>package mypkg</code>之后的注释<code>// import "x.y.z/mypkg"</code>对标准Go编译器是否有意义。</a>
	</li>
	</ul>
</li>
<li>
	控制流相关的细节：
	<ul>
	<li>
		<a href="#default-branch-position">在<code>switch</code> 和 <code>select</code>代码块里，<code>default</code>分支可以放在所有的<code>case</code>分支之前，所有的<code>case</code>分支之后，以及<code>case</code>分支之间。</a>
	</li>
	<li>
		<a href="#constant-case-expressions">在<code>switch</code>代码块里的数字常量case表达式不能够重复，但是布尔可以。</a>
	</li>
	<li>
		<a href="#switch-expressions-are-typed">在<code>switch</code>代码块里的switch表达式总是计算为类型化值。</a>
	</li>
	<li>
		<a href="#default-switch-expression-value"><code>switch</code>代码块中的default switch表达式是预声明类型<code>bool</code>的类型值<code>true</code>。</a>
	</li>
	<li>
		<a href="#open-brace-on-the-next-line">有时候，显示代码块的开括号<code>{</code>可以放在下一行。</a>
	</li>
	<li>
		<a href="#some-case-branch-blocks-must-be-explicit">部分<code>case</code>分支代码块必须是显式的。</a>
	</li>
	<li>
		<a href="#defer-modify-results">嵌套的defered函数调用可以修改所嵌套函数返回结果的值。</a>
	</li>
	<li>
		<a href="#no-op-recover-calls">部分<code>recover</code>调用可以是NoOps。</a>
	</li>
	<li>
		<a href="#os-exit-runtime-goexit">用一个<code>os.Exit</code>函数调用退出一个程序和用一个<code>runtime.Goexit</code>函数调用退出一个goroutine。</a>
	</li>
	</ul>
</li>
<li>
	操作符相关的细节：
	<ul>
	<li>
		<a href="#some-operator-precedence">递增运算符<code>++</code>和递减运算符<code>--</code>的优先级低于解引用(dereference)运算符<code>*</code>和取地址运算符<code>&amp;</code>，这两个运算符的优先级低于选择器<code>.</code>中的属性选择运算符。</a>
	</li>
	<li>
		<a href="#type-deduction-in-bit-shift">位移操作的左无类型操作数的类型推断规则取决于右操作数是否是常量。</a>
	</li>
	</ul>
</li>
<li>
	指针相关的细节：
	<ul>
	<li>
		<a href="#conversion-of-pointers-with-different-underlying-types">如果具有不同底层类型的两个指针类型的基础类型共享相同的底层类型，则可以将其值相互转换。</a>
	</li>
	<li>
		<a href="#addresses-of-zeor-sized-values">不同的零大小值的地址可能相等，也可能或不相等。</a>
	</li>
	<li>
		<a href="#self-based-pointer-type">指针类型的基础类型可能是指针类型自身。</a>
	</li>
	<li>
		<a href="#pointer-selector-shorthands">有关选择器速记的细节。</a>
	</li>
	</ul>
</li>
<li>
	容器相关的细节：
	<ul>
	<li>
		<a href="#composite-literal-simplification">有时候，嵌套组合字面值可以简化。</a>
	</li>
	<li>
		<a href="#use-pointer-as-array">在部分场景下，可以使用数组指针作为数组。</a>
	</li>
	<li>
		<a href="#nil-map-element-retrieving">从空(nil)映射里检索元素不会导致崩溃(panic)。其结果是一个零元素值。</a>
	</li>
	<li>
		<a href="#nil-map-element--deletion">从一个空(nil)映射删除一个条目不会导致崩溃(panic)。这是一个无操作(no-op)。</a>
	</li>
	<li>
		<a href="#append-slice-elements">切片调用<code>append</code>函数的结果可能会与原始切片共享一些元素，也可能不会。</a>
	</li>
	<li>
		<a href="#subslice">子切片的长度可能大于子切片派生自的基切片。</a>
	</li>
	<li>
		<a href="#derive-from-nil-slice">如果子切片表达式中使用的所有索引都为零，则从空(nil)切片中派生子切片是可以的。子切片的结果同样是一个空切片。</a>
	</li>
	<li>
		<a href="#range-over-nil-map-and-slice">在空映射或者空切片上用range遍历是可以的，这是一个无操作(no-op)。</a>
	</li>
	<li>
		<a href="#range-over-nil-array-pointer">如果第二个迭代变量被忽略或省略，那么在空(nil)数组指针上用range遍历是可以的。</a>
	</li>
	<li>
		<a href="#modify-slice-length-and-capacity-separately">切片的长度和容量可以单独修改。</a>
	</li>
	<li>
		<a href="#indexes-in-composite-literals"">切片和数组复合字面值中的索引必须是常量和非负值。</a>
	</li>
	<li>
		<a href="#constant-keys-in-composite-literals"">切片/数组/映射复合字面值的常量索引和键不能重复。</a>
	</li>
	<li>
		<a href="#array-slice-element-addressability">不可寻址的数组的元素依旧时不可寻址的，但是不可寻址的切片的元素总是可寻址的。</a>
	</li>
	<li>
		<a href="#array-slice-derivable">可以从不可寻址的切片中派生子切片，但是不能从不可寻址的数组中派生子切片。可以从不可寻址的切片中取元素的地址，但是不能从不可寻址的数组中取元素的地址。</a>
	</li>
	<li>
		<a href="#nan-as-map-keys">把以<code>NaN</code>作为键的元素放在映射上就像把元素放到黑洞里一样。</a>
	</li>
	<li>
		<a href="#capacity-of-slice-from-string">将字符串转换为字节/符文的结果切片的容量可能会大于结果切片的长度。</a>
	</li>
	<li>
		<a href="#different-loops">对于切片<code>s</code>，循环<code>for i = range s {...}</code> 不等于循环<code>for i = 0; i < len(s); i++ {...}</code>。</a>
	</li>
	</ul>
</li>
<li>
	函数和方法相关的细节：
	<ul>
	<li>
		<a href="#call-as-expression">当调用用做赋值中的源或另一个函数调用的参数时，多结果函数调用并不能与其它表达式混合。</a>
	</li>
	<li>
		<a href="#compile-time-evaluated-calls">部分函数调用可以在编译时求值。</a>
	</li>
	<li>
		<a href="#method-as-function">每一个方法都与一个隐式函数相关。</a>
	</li>
	</ul>
</li>
<li>
	接口相关的细节：
	<ul>
	<li>
		<a href="#comparison-interfaces-may-panic">将两个接口值与相同的动态不可比较类型进行比较会产生崩溃(panic)。</a>
	</li>
	<li>
		<a href="#type-assertion-to-interface-type">类型推断可以用于转换一个接口类型的值为另一个接口类型，即使前一种接口类型不实现后一种接口类型。</a>
	</li>
	<li>
		<a href="#failed-type-assertion-may-panic">类型断言的第二个可选结果是否存在将影响类型断言的行为。</a>
	</li>
	<!--
	<li>
		<a href="#interface-comparison-complexity">For the standard Go compiler, the time complexity of comparing two equal interface values may be <code><i>O</i>(1)</code> or <code><i>O</i>(n)</code>.</a>
	</li>
	<li>
		<a href="#interface-copy-complexity">For the standard Go compiler, the time complexity of copying an interface value is <code><i>O</i>(1)</code>.</a>
	</li>
	-->
	<li>
		<a href="#errors-new-different-returns">以相同参数调用两次<code>errors.New</code>返回的两个<code>错误</code>值是不相等的。</a>
	</li>
	</ul>
</li>
<li>
	管道相关的细节：
	<ul>
	<li>
		<a href="#receive-only-channel-canot-be-closed">仅接收的管道不能关闭。</a>
	</li>
	<li>
		<a href="#send-to-closed-channel-is-non-blocking">将一个值发送到一个关闭的通道被视为一个非阻塞操作，该操作会引起崩溃(panic)。</a>
	</li>
	</ul>
</li>
<li>
	更多关于类型和值的细节：
	<ul>
	<li>
		<a href="#local-type-declaration">类型可以在函数体内被声明。</a>
	</li>
	<li>
		<a href="#final-zero-size-field">对于标准编译器，结构体中零大小的字段会被视为一个比特大小的值。</a>
	</li>
	<li>
		<a href="#nan-inf">NaN != NaN, Inf == Inf.</a>
	</li>
	<li>
		<a href="#non-exported-names-from-different-packages">来自不同包的非导出方法名和结构体字段名被视为不同的名称。</a>
	</li>
	</ul>
</li>
<li>
	杂项：
	<ul>
	<li>
		<a href="#sometimes-parentheses-are-required">在一些罕见场景里，需要使用圆括号才能使代码编译通过。</a>
	</li>
	<!--
	<li>
		<a href="#main-entry-function-absence">A program doesn't need a <code>main</code> entry function to run.</a>
	</li>
	-->
	<li>
		<a href="#stack-overflow-is-not-panic">栈溢出不是崩溃(panic)。</a>
	</li>
	<li>
		<a href="#some-evaluation-order-are-compiler-dependent">部分表达式的求值顺序在Go里依赖于编译器实现。</a>
	</li>

	</ul>
</li>
<li>
	标准包相关的细节：
	<ul>
	<li>
		<a href="#reflect-deep-equal"><code>reflect.DeepEqual(x, y)</code> 和 <code>x == y</code>的结果可能会不同。</a>
	</li>
	<li>
		<a href="#check-file-existent">我们必须使用<code>os.IsNotExist(err)</code>而不是<code>err == os.ErrNotExist</code>来检查文件是否存在。</a>
	</li>
	<li>
		<a href="#boolean-flag">标准包<code>flag</code>对待布尔命令标志不同于整数和字符串标志。</a>
	</li>
	<li>
		<a href="#printf-positional-arguments"><code>[Sp|Fp|P]rintf</code>支持位置参数。</a>
	</li>
	</ul>
</li>
</ul>
</div>

<p class="anchor" id="import-package-multiple-times"></p>
<h3>一个包可以在源文件里被导入多次。</h3>

<div>
<p>
一个Go源文件可以多次导入同一个包。，
但是导入的名称必须不同。
这些相同的包导入引用着同一个包实例。
</p>

示例如下：
<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "io"
import inout "io"

func main() {
	fmt.Println(&inout.EOF == &io.EOF) // true
}
</code></pre>
</div>

<p class="anchor" id="force-import-path"></p>
<h3>在<code>package mypkg</code>之后的注释<code>// import "x.y.z/mypkg"</code>对标准Go编译器是否有意义。</h3>

<div>
例如，当标准编译器编译导入此包的源文件时，以下包的导入路径必须是 <code>"x.y.z/mypkg"</code>。

<pre class="line-numbers"><code class="language-go">package mypkg // import "x.y.z/mypkg"
...
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="default-branch-position"></p>
<h3>在<code>switch</code> 和 <code>select</code>代码块里，<code>default</code>分支可以放在所有的<code>case</code>分支之前，所有的<code>case</code>分支之后，以及<code>case</code>分支之间。</h3>

<div>
For example:

<pre class="line-numbers"><code class="language-go">	switch n := rand.Intn(3); n {
	case 0: fmt.Println("n == 0")
	case 1: fmt.Println("n == 1")
	default: fmt.Println("n == 2")
	}

	switch n := rand.Intn(3); n {
	default: fmt.Println("n == 2")
	case 0: fmt.Println("n == 0")
	case 1: fmt.Println("n == 1")
	}

	switch n := rand.Intn(3); n {
	case 0: fmt.Println("n == 0")
	default: fmt.Println("n == 2")
	case 1: fmt.Println("n == 1")
	}

	var x, y chan int

	select {
	case <-x:
	case y <- 1:
	default:
	}

	select {
	case <-x:
	default:
	case y <- 1:
	}

	select {
	default:
	case <-x:
	case y <- 1:
	}
</code></pre>

<p>
</p>

</div>

<p class="anchor" id="constant-case-expressions"></p>
<h3>在<code>switch</code>代码块里的数字常量case表达式不能够重复，但是布尔可以。</h3>

<div>
例如，下列程序在编译时会失败。

<pre class="line-numbers"><code class="language-go">package main

func main() {
	switch 123 {
	case 123:
	case 123: // error: duplicate case
	}
}
</code></pre>

但是下列程序在编译时是正常的。

<pre class="line-numbers"><code class="language-go">package main

func main() {
	switch false {
	case false:
	case false:
	}
}
</code></pre>

<p>
关于原因，请阅读<a href="https://github.com/golang/go/issues/28357">这个问题</a>。
这个行为依赖于编译器。
事实上，标准的Go编译器同样不允许重复的字符串case表达式，但是gccgo允许。
</p>
</div>

<p class="anchor" id="switch-expressions-are-typed"></p>
<h3>在<code>switch</code>代码块里的switch表达式总是计算为类型化值。</h3>

<div>
例如，在下列<code>switch</code>代码块中的switch表达式<code>123</code>被视为一个<code>int</code>值，而不是一个无类型的整数。

<pre class="line-numbers"><code class="language-go">package main

func main() {
	switch 123 {
	case int64(123):  // error: mismatched types
	case uint32(789): // error: mismatched types
	}
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="default-switch-expression-value"></p>
<h3><code>switch</code>代码块中的default switch表达式是预声明类型<code>bool</code>的类型值<code>true</code>。</h3>

<div>
For example, the following program will print <code>true</code>.
例如，下列程序会打印<code>true</code>。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	switch { // <=> switch true {
	case true:  fmt.Println("true")
	case false: fmt.Println("false")
	}
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="open-brace-on-the-next-line"></p>
<h3>有时候，显示代码块的开括号<code>{</code>可以放在下一行。</h3>

<div>
例如：

<pre class="line-numbers"><code class="language-go">package main

func main() {
	var i = 0
Outer:
	for
	{ // okay on the next line
		switch
		{ // okay on the next line
		case i == 5:
			break Outer
		default:
			i++
		}
	}
}
</code></pre>

<p></p>

下面程序的结果会打印什么？<code>true</code> 还是 <code>false</code>?
答案是<code>true</code>。
关于原因请阅读<a href="line-break-rules.html">Go的断行规则</a>。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func False() bool {
	return false
}

func main() {
	switch False()
	{
	case true:  fmt.Println("true")
	case false: fmt.Println("false")
	}
}
</code></pre>

<p>
</p>

</div>

<p class="anchor" id="some-case-branch-blocks-must-be-explicit"></p>
<h3>部分<code>case</code>分支代码块必须是显式的。</h3>

<div>
例如，下面的程序会在编译时失败。

<pre class="line-numbers"><code class="language-go">func demo(n, m int) (r int) {
	switch n {
	case 123:
		if m > 0 {
			goto End
		}
		r++

		End: // syntax error: missing statement after label
	default:
		r = 1
	}
	return
}
</code></pre>

为了编译通过，<code>case</code>分支代码块必须是显式的：

<pre class="line-numbers"><code class="language-go">func demo(n, m int) (r int) {
	switch n {
	case 123: {
		if m > 0 {
			goto End
		}
		r++

		End:
	}
	default:
		r = 1
	}
	return
}
</code></pre>

另外，我们可以在标签<code>End:</code>之后加一个分号：

<pre class="line-numbers"><code class="language-go">func demo(n, m int) (r int) {
	switch n {
	case 123:
		if m > 0 {
			goto End
		}
		r++

		End:;
	default:
		r = 1
	}
	return
}
</code></pre>

<p>
关于原因，请阅读<a href="line-break-rules.html">Go的断行规则</a>。
</p>

</div>

<p class="anchor" id="defer-modify-results"></p>
<h3>嵌套的defered函数调用可以修改所嵌套函数返回结果的值。</h3>

<div>
例如：

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func F() (r int) {
	defer func() {
		r = 789
	}()

	return 123 // <=> r = 123; return
}

func main() {
	fmt.Println(F()) // 789
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="no-op-recover-calls"></p>
<h3>部分<code>recover</code>调用可以是NoOps。</h3>

<p>
我们需要在正确的地方调用<code>recover</code>函数。
关于细节请阅读 <a href="panic-and-recover-more.html">调用内置函数<code>recover</code>的正确位置</a>。
</p>

<p class="anchor" id="os-exit-runtime-goexit"></p>
<h3>用一个<code>os.Exit</code>函数调用退出一个程序和用一个<code>runtime.Goexit</code>函数调用退出一个goroutine。</h3>

<!--
https://github.com/golang/go/issues/29226 a bug of goexit
-->

<div>
<p>
我们可以通过调用<code>os.Exit</code>函数从任何函数里退出一个程序。
<code>os.Exit</code>函数调用以<code>int</code> 代码作为参数并将代码返回给操作系统。
</p>

示例如下：

<pre class="line-numbers"><code class="language-go">// exit-example.go
package main

import "os"
import "time"

func main() {
	go func() {
		time.Sleep(time.Second)
		os.Exit(1)
	}()
	select{}
}
</code></pre>

运行：

<pre class="output"><code>$ go run a.go
exit status 1
$ echo $?
1
</code></pre>

<p>
</p>

<p>
我们可以通过调用<code>runtime.Goexit</code>函数退出一个goroutine。
<code>runtime.Goexit</code>函数不需要参数。
</p>

在下列示例里，单词<code>Java</code>将不会被打印。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "runtime"

func main() {
	c := make(chan int)
	go func() {
		defer func() {c <- 1}()
		defer fmt.Println("Go")
		func() {
			defer fmt.Println("C")
			runtime.Goexit()
		}()
		fmt.Println("Java")
	}()
	<-c
}
</code></pre>

<p>
</p>

</div>

<p class="anchor" id="some-operator-precedence"></p>
<h3>递增运算符<code>++</code>和递减运算符<code>--</code>的优先级低于解引用(dereference)运算符<code>*</code>和取地址运算符<code>&amp;</code>，这两个运算符的优先级低于选择器<code>.</code>中的属性选择运算符。</h3>

<div>
例如：

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

type T struct {
	x int
	y *int
}

func main() {
	var t T
	p := &t.x // <=> p := &(t.x)
	fmt.Printf("%T\n", p) // *int

	*p++ // <=> (*p)++
	*p-- // <=> (*p)--

	t.y = p
	a := *t.y
	fmt.Printf("%T\n", a) // int
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="type-deduction-in-bit-shift"></p>
<h3>位移操作的左无类型操作数的类型推断规则取决于右操作数是否是常量。</h3>

<div>


<pre class="line-numbers"><code class="language-go">package main

func main() {
}

const M  = 2
var _ = 1.0 << M // compile okay. 1.0 is deduced as an int value.

var N = 2
var _ = 1.0 << N // fail to compile. 1.0 is deduced as a float64 value.
</code></pre>

<p>
关于原因请阅读<a href="operators.html#bitwise-shift-left-operand-type-deduction">这一章节</a>。 
</p>
</div>

<p class="anchor" id="conversion-of-pointers-with-different-underlying-types"></p>
<h3>如果具有不同底层类型的两个指针类型的基础类型共享相同的底层类型，则可以将其值相互转换。</h3>

<div>

例如：

<pre class="line-numbers"><code class="language-go">package main

type MyInt int64
type Ta    *int64
type Tb    *MyInt

func main() {
	var a Ta
	var b Tb
	// Direct conversion is impossible.
	//a = Ta(b) // error: fail to compile

	// But indirect conversion is possible.
	y := (*MyInt)(b)
	x := (*int64)(y)
	a = x           // <=> the next line
	a = (*int64)(y) // <=> the next line
	a = (*int64)((*MyInt)(b))
	_ = a
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="addresses-of-zeor-sized-values"></p>
<h3>不同的零大小值的地址可能相等，也可能或不相等。</h3>
<!--
https://github.com/golang/go/issues/12726
-->

<div>
两个零大小值的地址是否相等时依赖于编译器以及编译器版本。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	a := struct{}{}
	b := struct{}{}
	x := struct{}{}
	y := struct{}{}
	m := [10]struct{}{}
	n := [10]struct{}{}
	o := [10]struct{}{}
	p := [10]struct{}{}

	fmt.Println(&x, &y, &o, &p)

	// For the standard Go compiler (1.11),
	// x, y, o and p escape to heap,
	// but a, b, m and n are allocated on stack.

	fmt.Println(&a == &b) // false
	fmt.Println(&x == &y) // true
	fmt.Println(&a == &x) // false

	fmt.Println(&m == &n) // false
	fmt.Println(&o == &p) // true
	fmt.Println(&n == &p) // false
}
</code></pre>

<p>
上面代码中所示的输出是针对标准Go编译器1.11的。
</p>
</div>

<p class="anchor" id="self-based-pointer-type"></p>
<h3>指针类型的基础类型可能是指针类型自身。</h3>

<div>

例如：

<pre class="line-numbers"><code class="language-go">package main

func main() {
	type P *P
	var p P
	p = &p
	p = **************p
}
</code></pre>

<p>
</p>

类似的，
<ul>
<li>
	切片类型的元素类型可以是切片类型自身，
</li>
<li>
	映射类型的元素类型可以是映射类型自身，
</li>
<li>
	管道类型的元素类型可以是管道类型自身，
</li>
<li>
	函数类型的参数和返回值类型可以是函数类型自身。
</li>
</ul>

<pre class="line-numbers"><code class="language-go">package main

func main() {
	type S []S
	type M map[string]M
	type C chan C
	type F func(F) F

	s := S{0:nil}
	s[0] = s
	m := M{"Go": nil}
	m["Go"] = m
	c := make(C, 3)
	c <- c; c <- c; c <- c
	var f F
	f = func(F)F {return f}

	_ = s[0][0][0][0][0][0][0][0]
	_ = m["Go"]["Go"]["Go"]["Go"]
	<-<-<-c
	f(f(f(f(f))))
}
</code></pre>

<p>
</p>

</div>

<p class="anchor" id="pointer-selector-shorthands"></p>
<h3>有关选择器速记的细节。</h3>

<div>

<p>
<p>
对于一个已定义或者未定义类型的指针值，如果它的（指针）类型的基础类型是结构体类型，
那么指针值可以选择它引用的结构体值的<b>字段</b>。
然而，如果指针值的类型是已定义类型，则该值不能选择其引用的值的方法。
</p>

<pre class="line-numbers"><code class="language-go">package main

type T struct {
	x int
}
func (T) m(){} // T has one method.

type P *T  // a defined one-level pointer type.
type PP *P // a defined two-level pointer type.

func main() {
	var t T
	var tp = &t
	var tpp = &tp
	var p P = tp
	var pp PP = &p
	tp.x = 12  // okay
	p.x = 34   // okay
	pp.x = 56  // error: type PP has no field or method x
	tpp.x = 78 // error: type **T has no field or method x)

	tp.m()  // okay. Type *T also has a "m" method.
	p.m()   // error: type P has no field or method m
	pp.m()  // error: type PP has no field or method m
	tpp.m() // error: type **T has no field or method m
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="composite-literal-simplification"></p>
<h3>有时候，嵌套组合字面值可以简化。</h3>

<p>
关于细节请阅读 <a href="container.html#composite-literal-simplification">这一章节</a>。 
</p>

<p class="anchor" id="use-pointer-as-array"></p>
<h3>在部分场景下，可以使用数组指针作为数组。</h3>

<p>
关于细节请阅读<a href="container.html#use-pointer-as-array">这一章节</a>。 
</p>

<p class="anchor" id="nil-map-element-retrieving"></p>
<h3>从空(nil)映射里检索元素不会导致崩溃(panic)。其结果是一个零元素值。</h3>

<div>

例如，函数<code>Foo1</code>和<code>Foo2</code>是相等的，但是函数<code>Foo2</code>比函数
<code>Foo1</code>整洁多了。

<pre class="line-numbers"><code class="language-go">func Foo1(m map[string]int) int {
	if m != nil {
		return m["foo"]
	}
	return 0
}

func Foo2(m map[string]int) int {
	return m["foo"]
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="nil-map-element--deletion"></p>
<h3>从一个空(nil)映射删除一个条目不会导致崩溃(panic)。这是一个无操作(no-op)。</h3>

<div>

例如，下列程序不会崩溃(panic)。

<pre class="line-numbers"><code class="language-go">package main

func main() {
	var m map[string]int // nil
	delete(m, "foo")
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="append-slice-elements"></p>
<h3>切片调用<code>append</code>函数的结果可能会与原始切片共享一些元素，也可能不会。</h3>

<p>
关于细节请阅读<a href="container.html#element-addition-deletion">这一章节</a>。 
</p>

<p class="anchor" id="subslice"></p>
<h3>子切片的长度可能大于子切片派生自的基切片。</h3>

<div>

例如，

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	s := make([]int, 3, 9)
	fmt.Println(len(s)) // 3
	s2 := s[2:7]
	fmt.Println(len(s2)) // 5
}
</code></pre>

<p>
关于细节请阅读<a href="container.html#subslice">这一章节</a>。
</p>
</div>

<p class="anchor" id="derive-from-nil-slice"></p>
<h3>如果子切片表达式中使用的所有索引都为零，则从空(nil)切片中派生子切片是可以的。子切片的结果同样是一个空切片。</h3>

<div>

例如，下面的程序在运行时不会崩溃(panic)。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	var x []int // nil
	a := x[:]
	b := x[0:0]
	c := x[:0:0]
	// Print three "true".
	fmt.Println(a == nil, b == nil, c == nil)
}
</code></pre>

<p>
关于细节请阅读<a href="container.html#subslice">这一章节</a>。
</p>
</div>

<p class="anchor" id="range-over-nil-map-and-slice"></p>
<h3>在空映射或者空切片上测距(ranging over)是可以的，这是一个无操作(no-op)。</h3>

<div>

For example, the following program compiles okay.
例如，下面的程序可以编译通过。

<pre class="line-numbers"><code class="language-go">package main

func main() {
	var s []int // nil
	for range s {
	}

	var m map[string]int // nil
	for range m {
	}
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="range-over-nil-array-pointer"></p>
<h3>如果第二个迭代变量被忽略或省略，那么在空(nil)数组指针上用range遍历是可以的。</h3>

<div>

例如，下面的程序会输出<code>01234</code>。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	var a *[5]int // nil
	for i, _ := range a {
		fmt.Print(i)
	}
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="modify-slice-length-and-capacity-separately"></p>
<h3>切片的长度和容量可以单独修改。</h3>

<p>
我们可以通过反射的返回单独修改一个切片的长度和容量。
关于细节请阅读<a href="container.html#modify-slice-length-and-capacity">这一章节</a>。 
</p>

<p class="anchor" id="indexes-in-composite-literals"></p>
<h3>切片和数组复合字面值中的索引必须是常量和非负值。</h3>

<div>
For example, the following code fails to compile.
例如，下面的程序会在编译时失败。

<pre class="line-numbers"><code class="language-go">var k = 1
var x = [2]int{k: 1} // error: index must be non-negative integer constant
var y = []int{k: 1}  // error: index must be non-negative integer constant
</code></pre>

<p>
注意，映射复合字面值中的键不需要是常量。
</p>
</div>

<p class="anchor" id="constant-keys-in-composite-literals"></p>
<h3>切片/数组/映射复合字面值的常量索引和键不能重复。</h3>

<div>
例如，下面的程序会在编译时失败。

<pre class="line-numbers"><code class="language-go">// error: duplicate index in array literal: 1
var a = []bool{0: false, 1: true, 1: true}
// error: duplicate index in array literal: 0
var b = [...]string{0: "foo", 1: "bar", 0: "foo"}
// error: duplicate key "foo" in map literal
var c = map[string]int{"foo": 1, "foo": 2}
</code></pre>

<p>
这个特性可以用于<a href="tips.html#assert-at-compile-time">在编译时断言某些条件</a>。
</p>
</div>

<p class="anchor" id="array-slice-element-addressability"></p>
<h3>不可寻址的数组的元素依旧时不可寻址的，但是不可寻址的切片的元素总是可寻址的。</h3>

<div>
<p>
原因是数组值的元素，当数组存储在内存中时，数组将存储在相同的内存块中。
但是 <a href="unofficial-faq.html#slice-elements-always-addressable">切片的情况就完全不同</a>。
</p>

例如：

<pre class="line-numbers"><code class="language-go">package main

func main() {
	// Container composite literals and map elements are all unaddressable.

	// Take container element addresses.
	_ = &[]int{1}[0] // ok
	_ = &[5]int{}[0] // error: cannot take the address of [5]int literal[0]
	_ = &(&[5]int{})[0] // ok
	_ = &(*&[5]int{})[0] // ok

	// Modify container element values.
	map[int]int{}[1] = 9
	[]int{1,2,3}[1] = 9
	[3]int{1,2,3}[1] = 9 // error: cannot assign to [3]int literal[1]
	(&[3]int{1,2,3})[1] = 9
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="array-slice-derivable"></p>
<h3>
可以从不可寻址的切片中派生子切片，但是不能从不可寻址的数组中派生子切片。
可以从不可寻址的切片中取元素的地址，但是不能从不可寻址的数组中取元素的地址。
</h3>

<div>
<p>
原因和最后一个细节是一样的。
</p>

例如：
<pre class="line-numbers"><code class="language-go">package main

func main() {
	// Literal values and map elements are unaddressable in Go.

	// The following lines fail to compile.
	/*
	_ = [...]int{6, 7, 8, 9}[1:3]  // error: slice of unaddressable value
	_ = &([...]int{6, 7, 8, 9}[0]) // error: cannot take element address
	var ma = map[string][4]int{"abc": {0, 1, 2, 3}}
	_ = ma["abc"][1:3]  // error: slice of unaddressable value
	_ = &(ma["abc"][0]) // error: cannot take element address
	*/

	// The following lines compile okay.
	_ = []int{6, 7, 8, 9}[1:3]
	_ = &([]int{6, 7, 8, 9}[0])
	var ms = map[string][]int{"abc": {0, 1, 2, 3}}
	_ = ms["abc"][1:3]
	_ = &(ms["abc"][0])
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="nan-as-map-keys"></p>
<h3>把以<code>NaN</code>作为键的元素放在映射上就像把元素放到黑洞里一样。</h3>

<div>
原因是<code>NaN != NaN</code>（细节见下文）。
以<code>NaN</code>作为键的元素只能在<code>for-range</code>循环中被找到。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "math"

func main() {
	var a = math.NaN()
	fmt.Println(a)      // NaN

	var m = map[float64]int{}
	m[a] = 123
	v, present := m[a]
	fmt.Println(v, present) // 0 false
	m[a] = 789
	v, present = m[a]
	fmt.Println(v, present) // 0 false

	fmt.Println(m) // map[NaN:&lt;nil&gt; NaN:&lt;nil&gt;]
	delete(m, a) // no-op
	fmt.Println(m) // map[NaN:&lt;nil&gt; NaN:&lt;nil&gt;]

	for k, v := range m {
		fmt.Println(k, v)
	}
	// the above loop outputs:
	// NaN 123
	// NaN 789
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="capacity-of-slice-from-string"></p>
<h3>将字符串转换为字节/符文的结果切片的容量可能会大于结果切片的长度。</h3>

<div>
<p>
我们不能假设结果切片的长度和容量总是相等的。
</p>

在下面的例子中，如果最后一个<code>fmt.Println</code>行被删除，在其前面的两行会打印相同的值 <code>32</code>，
否则，一个打印<code>32</code>，一个打印<code>8</code>。
（适用于标准的Go编译器1.11。）

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	s := "a"
	x := []byte(s)              // len(s) == 1
	fmt.Println(cap([]byte(s))) // 32
	fmt.Println(cap(x))         // 8
	fmt.Println(x)
}
</code></pre>

<p>
如果我们假设结果切片的长度和容量总是相等，<a href="https://github.com/go101/go101/wiki/The-capacity-of-the-result-byte-%28or-rune%29-slice-of-a-conversion-from-a-string-is-undefined">就会写出一些有bug的代码</a>。 
</p>
</div>

<p class="anchor" id="different-loops"></p>
<h3>对于切片<code>s</code>，循环<code>for i = range s {...}</code> 不等于循环<code>for i = 0; i < len(s); i++ {...}</code>。</h3>

<div>
对于这两个循环，迭代变量<code>i</code>的最终值可能是不同的。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

var i int

func fa(s []int, n int) int {
	i = n
	for i = 0; i < len(s); i++ {}
	return i
}

func fb(s []int, n int) int {
	i = n
	for i = range s {}
	return i
}

func main() {
	s := []int{2, 3, 5, 7, 11, 13}
	fmt.Println(fa(s, -1), fb(s, -1)) // 6 5
	s = nil
	fmt.Println(fa(s, -1), fb(s, -1)) // 0 -1
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="call-as-expression"></p>
<h3>当调用用做赋值中的源或另一个函数调用的参数时，多结果函数调用并不能与其它表达式混合</h3>

<p>
关于细节请阅读<a href="function.html#call-as-expression">这一章节</a>。
</p>

<p class="anchor" id="compile-time-evaluated-calls"></p>
<h3>部分函数调用可以在编译时求值。</h3>

<p>
关于细节请阅读<a href="function.html#compile-time-evaluated-calls">这一章节</a>。
</p>

<p class="anchor" id="method-as-function"></p>
<h3>每一个方法都与一个隐式函数相关。</h3>

<p>
关于细节请阅读<a href="function.html#compile-time-evaluated-calls">这一章节</a>。
</p>

<p class="anchor" id="comparison-interfaces-may-panic"></p>
<h3>将两个接口值与相同的动态不可比较类型进行比较会产生崩溃(panic)。</h3>

<div>
例如：

<pre class="line-numbers"><code class="language-go">package main

func main() {
	var x interface{} = []int{}
	_ = x == x // panic
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="type-assertion-to-interface-type"></p>
<h3>类型推断可以用于转换一个接口类型的值为另一个接口类型，即使前一种接口类型不实现后一种接口类型。</h3>

<div>
例如：

<pre class="line-numbers"><code class="language-go">package main

type Foo interface {
	foo()
}

type T int
func (T) foo() {}

func main() {
	var x interface{} = T(123)
	var _ Foo = x   // error: interface {} does not implement Foo
	var _ = Foo(x)  // error: interface {} does not implement Foo
	var _ = x.(Foo) // okay
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="failed-type-assertion-may-panic"></p>
<h3>类型断言的第二个可选结果是否存在将影响类型断言的行为。</h3>

<div>
If the second optional result presents in a failed type assertion, the type assertion will not produce a panic.
Otherwise, a panic will occur.
如果第二个可选结果出现在失败的类型断言中，那么类型断言不会产生崩溃(panic)。
否则，会发生崩溃(panic)。
例如：

<pre class="line-numbers"><code class="language-go">package main

func main() {
	var x interface{} = true
	_, _ = x.(int) // assertion fails, but doesn't cause a panic.
	_ = x.(int)    // assertion fails, which causes a panic.
}
</code></pre>

<p>
</p>
</div>



<!--
<p class="anchor" id="interface-comparison-complexity"></p>
<h3>For the standard Go compiler, the time complexity of comparing two equal interface values may be <code><i>O</i>(1)</code> or <code><i>O</i>(n)</code>.</h3>

<div>
The time complexity depends on whether or not the direct parts
of the two equal interfaces both reference the undrelying value.
Please read the article <a href="value-part.html#interface-structure">value parts</a> for detail.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "time"

func main() {
	bigarr := [1 << 20]int{}

	type I interface{}

	// i0, i1 and i2 are three equal interfaces.
	var i0 I = bigarr // the dynamic value of i0 is a copy of bigarr.
	var i1 I = bigarr // the dynamic value of i1 is also a copy of bigarr.
	                  // Note, the dynamic values of i0 and i1 are
	                  // two different copies of bigarr.
	var i2 I = i1 // i2 shares the same dynamic value copy with i1.

	startTime := time.Now()
	_ = i0 == i1
	duration := time.Since(startTime)
	fmt.Println("duration for (i0 == i1):", duration)

	startTime = time.Now()
	_ = i1 == i2
	duration = time.Since(startTime)
	fmt.Println("duration for (i1 == i2):", duration)
}
</code></pre>

The output:
<pre class="output"><code>duration for (i0 == i1): 1.381337ms
duration for (i1 == i2): 609ns
</code></pre>
<p>
1ms is 1000000ns!
</p>
</div>

<p class="anchor" id="interface-copy-complexity"></p>
<h3>About the time complexity of copying a non-nil interface value.</h3>

<p>
The <a href="https://golang.org/doc/faq#pass_by_value">official Go FAQ</a>
says <b><i>copying an interface value makes a copy of the thing stored in the interface value.</i></b>.
The article <a href="interface.html#boxing">interfaces in Go</a> mentions that,
for the standard Go compiler, the time complexity of copying an interface value
is <code><i>O</i>(1)</code>.
But the sizes of different dynamic values stored in interface values may
be different, why isn't the complexity <code><i>O</i>(n)</code>?
</p>

<p>
The reason is the dynamic values of interface values are all inmutable,
so the standard Go compiler makes an optimization here.
As the article <a href="value-part.html#interface-structure">value parts</a>
has explained, an non-nil interface value has an underlying part and
the direct part of the interface value stores a pointer which
references the underlying part. When the interface value is copied,
only its direct part is copied. For the standard Go compiler,
the sizes of the direct parts of all interface values are the same.
</p>
-->

<p class="anchor" id="errors-new-different-returns"></p>
<h3>以相同参数调用两次<code>errors.New</code>返回的两个<code>错误</code>值是不相等的。</h3>

<div>
原因是 <code>errors.New</code>函数会复制输入的字符串参数并用一个复制字符串的指针作为返回<code>error</code>值的动态值。
两次调用会产生两个不同的指针。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "errors"

func main() {
	notfound := "not found"
	a, b := errors.New(notfound), errors.New(notfound)
	fmt.Println(a == b) // false
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="receive-only-channel-canot-be-closed"></p>
<h3>仅接收的管道不能关闭。</h3>

<div>
例如，下面的代码会在编译时候失败。

<pre class="line-numbers"><code class="language-go">package main

func main() {
}

func foo(c <-chan int) {
	close(c) // error: cannot close receive-only channel
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="send-to-closed-channel-is-non-blocking"></p>
<h3>将一个值发送到一个关闭的通道被视为一个非阻塞操作，该操作会引起崩溃(panic)。</h3>

<div>
例如，在下面的程序里，第二个case分支会被选择，会在运行发生崩溃(painc)。

<pre class="line-numbers"><code class="language-go">package main

func main() {
	var c = make(chan bool)
	close(c)
	select {
	case <-c:
	case c <- true: // panic: send on closed channel
	default:
	}
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="local-type-declaration"></p>
<h3>类型可以在函数体内被声明。</h3>

<div>
类型可以在函数体内被声明。例如，

<pre class="line-numbers"><code class="language-go">package main

func main() {
	type T struct{}
	type S = []int
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="final-zero-size-field"></p>
<h3>对于标准编译器，结构体中零大小的字段会被视为一个比特大小的值。</h3>

<p>
关于细节请阅读<a href="unofficial-faq.html#final-zero-size-field">这个FAQ条目</a>。
</p>

<p class="anchor" id="nan-inf"></p>
<h3>NaN != NaN, Inf == Inf.</h3>

<div>
这遵循IEEE-754标准并与大多数其它语言一致：
<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "math"

func main() {
	var a = math.Sqrt(-1.0)
	fmt.Println(a)      // NaN
	fmt.Println(a == a) // false

	var x = 0.0
	var y = 1.0 / x
	var z = 2.0 * y
	fmt.Println(y, z, y == z) // +Inf +Inf true
}
</code></pre>
<p>
</p>
</div>

<p class="anchor" id="non-exported-names-from-different-packages"></p>
<h3>来自不同包的非导出方法名和结构体字段名被视为不同的名称。</h3>

<div>
例如，下面在包<code>foo</code>中声明的类型：

<pre class="line-numbers"><code class="language-go">package foo

type I = interface {
	about() string
}

type S struct {
	a string
}

func (s S) about() string {
	return s.a
}
</code></pre>

以及下面在包<code>bar</code>声明的类型：

<pre class="line-numbers"><code class="language-go">package bar

type I = interface {
	about() string
}

type S struct {
	a string
}

func (s S) about() string {
	return s.a
}
</code></pre>

那么，
<ul>
<li>
	两个包中的两个类型 <code>S</code>的值不能相互转换。
</li>
<li>
	两个包中的两个接口类型表示两个不同的方法集。
</li>
<li>
	类型<code>foo.S</code>不实现接口类型 <code>bar.I</code>。
</li>
<li>
	类型<code>bar.S</code>不实现接口类型<code>foo.I</code>。
</li>
</ul>

<pre class="line-numbers"><code class="language-go">package main

import "包2/foo"
import "包2/bar"

func main() {
	var x foo.S
	var y bar.S
	var _ foo.I = x
	var _ bar.I = y

	// The following lines fail to compile.
	x = foo.S(y)
	y = bar.S(x)
	var _ foo.I = y
	var _ bar.I = x
}
</code></pre>

</div>

<p class="anchor" id="sometimes-parentheses-are-required"></p>
<h3>在一些罕见场景里，需要使用圆括号才能使代码编译通过。</h3>

<div>
例如：

<pre class="line-numbers"><code class="language-go">package main

type T struct{x, y int}

func main() {
	// Each of the following three lines makes code fail to compile.
	// Some "{}" confuse compilers.
	/*
	if T{} == T{123, 789} {}
	if T{} == (T{123, 789}) {}
	if (T{}) == T{123, 789} {}
	*/

	// We must add parentheses like the following two lines to
	// make code compile okay.
	if (T{} == T{123, 789}) {}
	if (T{}) == (T{123, 789}) {}
}
</code></pre>

<p>
</p>
</div>

<!--
<p class="anchor" id="main-entry-function-absence"></p>
<h3>A program doesn't need a <code>main</code> entry function to run.</h3>

<div>
The following program <a href="https://github.com/golang/go/issues/21256">compiles okay before Go 1.11</a>,
for the standard Go compiler.
But since Go 1.11, it fails to compile.

<pre class="line-numbers"><code class="language-go">package main

import (
    "fmt"
    "time"
)

func init() {
	for {
		time.Sleep(time.Second)
		fmt.Println("hi")
	}
}

var main int
</code></pre>

<p>
</p>
</div>
-->

<p class="anchor" id="stack-overflow-is-not-panic"></p>
<h3>栈溢出不是崩溃(panic)。</h3>

<div>

栈溢出在Go里是致命错误。一旦栈溢出发生，程序会以不可恢复的方式崩溃。

<pre class="line-numbers"><code class="language-go">package main

func f() {
	f()
}

func main() {
	f()
}
</code></pre>

运行结果是：

<pre class="output"><code>runtime: goroutine stack exceeds 1000000000-byte limit
fatal error: stack overflow

runtime stack:
...
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="some-evaluation-order-are-compiler-dependent"></p>
<h3>部分表达式的求值顺序在Go里依赖于编译器实现。</h3>

<p>
关于细节请阅读<a href="evaluation-orders.html">Go中的表达式求值顺序。</a> 
</p>

<p class="anchor" id="reflect-deep-equal"></p>
<h3><code>reflect.DeepEqual(x, y)</code> 和 <code>x == y</code>的结果可能会不同。</h3>

<p>
关于细节请阅读<a href="reflection.html#deep-equal">这一章节</a>。
</p>

<p class="anchor" id="check-file-existent"></p>
<h3>我们必须使用<code>os.IsNotExist(err)</code>而不是<code>err == os.ErrNotExist</code>来检查文件是否存在。</h3>

<div>

使用<code>err == os.ErrNotExist</code>可能漏掉一些错误。

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"os"
)

func main() {
	_, err := os.Stat("a-nonexistent-file.abcxyz")
	fmt.Println(os.IsNotExist(err))    // true
	fmt.Println(err == os.ErrNotExist) // false
}
</code></pre>

<p>
</p>
</div>

<p class="anchor" id="boolean-flag"></p>
<h3>标准包<code>flag</code>对待布尔命令标志不同于整数和字符串标志。</h3>

<div>
传递标志选项有三种形式。
<ol>
<li>
	<code>-flag</code>， 仅用于布尔标志。
</li>
<li>
	<code>-flag=x</code>， 用于任何标志。.
</li>
<li>
	<code>-flag x</code>， 仅用于非布尔标志。
</li>
</ol>

<p>
请注意，使用第一种形式的布尔标志后面的所有项都被视为参数。
</p>

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "flag"

var b = flag.Bool("b", true, "a boolean flag")
var i = flag.Int("i", 123, "an integer flag")
var s = flag.String("s", "hi", "a string flag")

func main() {
	flag.Parse()
	fmt.Print("b=", *b, ", i=", *i, ", s=", *s, "\n")
	fmt.Println("arguments:", flag.Args())
}
</code></pre>

<p>
</p>

如果我们用下面显示的标志和参数运行下面的程序

<pre class="output"><code>./exampleProgram -b false -i 789 -s bye arg0 arg1
</code></pre>

输出结果会是

<pre class="output"><code>b=true, i=123, s=hi
arguments: [false -i 789 -s bye arg0 arg1]
</code></pre>

<p>
这个输出显然不是我们所期望的
</p>

我们应该像这样传递标志和参数

<pre class="output"><code>./exampleProgram -b=false -i 789 -s bye arg0 arg1
</code></pre>

或者

<pre class="output"><code>./exampleProgram -i 789 -s bye -b arg0 arg1
</code></pre>

获取我们期望的输出：

<pre class="output"><code>b=true, i=789, s=bye
arguments: [arg0 arg1]
</code></pre>

</div>

<p class="anchor" id="printf-positional-arguments"></p>
<h3><code>[Sp|Fp|P]rintf</code>函数支持位置参数。</h3>

<div>
<p>
下面的程序会打印<code>3, 2, 1</code>。
</p>

例如：

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	fmt.Printf("%[3]v, %[2]v, %[1]v", 1, 2, 3) // 3, 2, 1
}
</code></pre>

<p>
</p>
</div>


<!--
<p class="anchor" id="remove-spaces-in-template"></p>
<h3>Since Go 1.6, we can .</h3>

https://golang.org/doc/go1.6 : {{a -}} sss {{- b}}



The exported fields and methods of embedded non-exported fields
are still exported for the embedding struct type.


json:"name: empty" // doesn't work

syscall package docs show current O arch defaultly
  https://golang.org/pkg/syscall/?GOOS=linux&GOARCH=mips64le

two unnamed struct types embedding two alias types which denote the same type are two different types.

non-exported field can't be set by reflection, but can be listed. Can read?

reflection created embedding type will not obtain meethods. still?

don't use == to compare two reflect.Value values, compare v1.Interface() and v2.Interface() instead (move to reflection article and tips)

don't use == compare two time.Time values, use time.EqualTo instead (move to tips)

https://golang.org/pkg/reflect/#pkg-note-BUG

https://golang.org/pkg/reflect/#Value.String
Print functions not always print the result of the String() method of a value.



size_t in go is int instead of uint, ..., good design. (to faq)

an untyped rune or int constant can be bound with a value which is larger than the max <code>rune</code> or <code>int</code> value in memory.

-128/-1 = -128


greedy goroutine https://github.com/golang/go/issues/10958
* It look some goroutines never get yielded, this make some other goroutines never get chances to run, why?
http://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do

internal package

"go doc xyz" may show the docs of the first package named with "xyz"
https://github.com/golang/go/issues/24462


runtime.Caller/ Callers: depth onconsistencys

https://github.com/golang/go/issues/13890

https://github.com/golang/go/issues/24693

https://github.com/golang/go/issues/24721

https://github.com/golang/go/issues/20135

Try not to use multi-value assignments.
Reason 1: maybe bug. Reason 3: unspecified behaviours. 2: maybe inefficient.
https://github.com/golang/go/issues/23188#issuecomment-361482955
https://github.com/golang/go/issues/23017
https://github.com/golang/go/issues/22881
https://github.com/golang/go/issues/24448

https://github.com/golang/go/issues/24746

https://github.com/golang/go/issues/26463 maps do not shrink

Values of <code>expvar.Int</code> and <code>expvar.Float</code> need to be 64-bit aligned.

func main() {
	var a, b = 1.0, 0.0
	x, y := a/b, 0.0
	println(x, y) // +Inf +0.000000e+000
	println(x * y) // NaN
}

io/ioutil since Go 1.11

    The TempFile function now supports specifying where the random characters in the filename are placed.
    If the prefix argument includes a "*", the random string replaces the "*".
    For example, a prefix argument of "myname.*.bat" will result in a random filename such as "myname.123456.bat".
    If no "*" is included the old behavior is retained, and the random digits are appended to the end.

go links 101
   https://stackoverflow.com/questions/7044944/jquery-javascript-to-detect-os-without-a-plugin
   https://golang.org/pkg/syscall/ list all OS/arch pages

//godo/doc/builder
var windowsOnlyPackages = map[string]bool{
	"internal/syscall/windows":                     true,
	"internal/syscall/windows/registry":            true,
	"golang.org/x/exp/shiny/driver/internal/win32": true,
	"golang.org/x/exp/shiny/driver/windriver":      true,
	"golang.org/x/sys/windows":                     true,
	"golang.org/x/sys/windows/registry":            true,
}

go term(inoledgie)s 101

go contests 101 / summaries / snippets

go games

go practices
	* wasm + box2d: jslib: {drawRect, drawCircle, ...}
	* crawler
	* go.*
	* channel: chat
	* game
	  * https://github.com/faiface/pixel/wiki/Drawing-shapes-with-IMDraw
	* gui
	* web dev
	* db
	* ML, AI
	  * https://mb-14.github.io/tech/2018/10/24/gomarkov.html
	* net
	  * https://old.reddit.com/r/golang/comments/9r4sb3/using_go_for_networking/
	*

go101 tools
	* golf
	* mac
	* doc
	* json beautify
	* detect bad 64-bit alignement expectations: https://github.com/golang/go/issues/11891#issuecomment-433623786
	* find default import name is not constent with the last token in import path
	* check depreciated go env vars
	* find useless loops: https://github.com/golang/go/issues/28313





-->








