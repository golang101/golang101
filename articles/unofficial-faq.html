<h1>Go FAQ 101</h1>

<p><i>
	(这是非官方的GO FAQ。正式版本请参考 <a href="https://golang.org/doc/faq">here</a>.)
</i></p>

<div>
索引：

<ul>
<li>编译器与运行时
	<ul>
	<li><a href="#error-non-name">编译器错误信息 <code>non-name *** on left side of :=</code> 意味着什么?</a></li>
	<li><a href="#error-missing-left-brace">编译器错误信息 <code>unexpected newline, expecting { after if clause</code> 意味着什么?</a></li>
	<li><a href="#error-declared-not-used">编译器错误信息 <code>declared and not used</code> 意味着什么?</a></li>
	<li><a href="#map-iteration-order">Go运行时是否维护maps的迭代顺序</a></li>
	<li><a href="#compiler-field-padding">Go编译器是否会进行填充以确保结构体类型的字段对齐？</a></li>
	<li><a href="#final-zero-size-field">为什么结构体中零大小类型的最后一个字段有时会影响结构体的大小？</a></li>
	<li><a href="#new-function"><code>new(T)</code> 是 <code>var t T; (&t)</code>的语法糖吗？</a></li>
	<li><a href="#fatal-error-deadlock">运行时错误信息 <code>all goroutines are asleep - deadlock</code> 意味着什么?</a></li>
	<li><a href="#64-bit-alignment">64位变量和结构体字段是否保证64位对齐以便可以原子地访问它们？</a></li>	
	<li><a href="#atomical-assignment">赋值是原子操作吗？</a></li>
	<li><a href="#zero-values-zero-bytes">是否每一个零值都是由内存中的零比特序列组成的？</a></li>
	<li><a href="#function-inline">标准的Go编译器是否支持内联函数？</a></li>
	</ul>
</li>

<li>标准库
	<ul>
	<li><a href="#pointer-atomic">如何原子地操作指针的值？</a></li>
	<li><a href="#get-days-of-month">如何使用尽可能短的代码行数来获取任意月份的天数？</a></li>
	<li><a href="#time-sleep-after">函数调用<code>time.Sleep(d)</code>和管道接收<code>&lt;-time.After(d)</code>操作之间有何区别？</a></li>
	<li><a href="#finalizers">可以使用finalizers作为对象的析构函数吗？</a></li>
	<li><a href="#trim">在<code>strings</code>和<code>bytes</code>标准包里调用<code>TrimLeft</code>和<code>TrimRight</code>函数经常会返回不可预知的结果，这是这些函数实现的bugs吗？</a></li>
	<li><a href="#fmt-print-println">函数<code>fmt.Print</code> 和 <code>fmt.Println</code> 的区别是什么？</a></li>
	<li><a href="#log-print-println">函数<code>log.Print</code> 和函数 <code>log.Println</code> 有什么区别吗?</a></li>
	<li><a href="#fmt-print-synced">函数 <code>fmt.Print</code>, <code>fmt.Println</code> 和 <code>fmt.Printf</code> 是同步的吗？</a></li>
	<li><a href="#print-builtin-fmt-log">内置的<code>print</code>/<code>println</code>函数与标准包<code>fmt</code>和<code>log</code>里相应的打印函数有什么区别？</a></li>
	<li><a href="#math-crypto-rand">通过标准包<code>math/rand</code>和<code>crypto/rand</code>生成的随机数之间有什么区别？</a></li>
	<li><a href="#math-round">为什么没有<code>math.Round</code> 函数？</a></li>
	</ul>
</li>

<li>类型系统
	<ul>
	<li><a href="#uncomparable-types">那些类型不支持比较？</a></li>
	<li><a href="#nil-equality">为什么两个<code>nil</code>值有时候会不相等？</a></li>
	<li><a href="#slice-conversion">为什么类型 <code>[]T1</code> 和 <code>[]T2</code>没有共享相同底层类型，即使不同的类型<code>T1</code> 和 <code>T2</code>共享相同的底层类型？</a></li>
	<li><a href="#unaddressable-values">哪些值可以取地址，哪些值不可以取地址？</a></li>
	<li><a href="#maps-are-unaddressable">为什么映射的元素不可取地址？</a></li>
	<li><a href="#slice-elements-always-addressable">为什么非空切片的元素总是可取地址，即便切片是不可取地址的？</a></li>
	<li><a href="#method-set-relation">对任意的非指针，非接口定义类型<code>T</code>，为什么<code>*T</code>的方法集总是<code>T</code>的方法集的超集，但是反之不然？</a></li>
	<li><a href="#types-can-have-methods">我们可以为哪些类型实现方法？</a></li>
	<li><a href="#declare-immutables">在Go里如何声明不可变的值？</a></li>
	<li><a href="#set-container-type">为什么没有内置的 <code>set</code> 容器类型？</a></li>
	<li><a href="#byte-rune-slice-string">什么是字节？什么是符文？如何将 <code>[]byte</code> 和 <code>[]rune</code>的值转换为字符串？</a></li>
	</ul>
</li>
<li>其它
	<ul>
	<li><a href="#about-iota"><code>iota</code> 是什么意思？</a></li>
	<li><a href="#check-if-channels-closed">为什么没有内置的<code>closed</code>函数检查管道是否关闭？</a></li>
	<li><a href="#return-local-pointers">返回本地变量指针的函数是否安全？</a></li>
	<li><a href="#gopher">单词<b><i>gopher</i></b>在Go社区代表什么？</a></li>
	</ul>
</li>


</ul>
</div>

<!-- compiler and runtime  -->

<p class="anchor" id="error-non-name"></p>
<h3>
	编译器错误信息 <code>non-name *** on left side of :=</code> 意味着什么?
</h3>

直到现在(Go 1.11), Go都有一个关于短变量声明的 <a href="https://golang.org/ref/spec#Short_variable_declarations">强制性规则</a>：
<div class="alert alert-success">
所有位于 <code>:=</code>符号左侧的条目都必须是纯粹的<a href="https://golang.org/ref/spec#Identifiers">标识符</a>，并且其中一个必须是一个新的变量名称。
</div>
这意味着容器元素 (<code>x[i]</code>)，结构体的域 (<code>x.f</code>)，指针取消引用和合格的标识符都不能够出现在<code>:=</code>符号的左侧。

<p>
目前，这个问题还是一个<a href="https://github.com/golang/go/issues/377">未解决问题</a>（已经和<a href="https://github.com/golang/go/issues/6842">一个相关问题</a>合并）。不过似乎Go的作者想要在Go 2.0发布之前一直将这个问题列为未解决问题。
</p>

<p class="anchor" id="error-missing-left-brace"></p>
<h3>
	编译器错误信息 <code>unexpected newline, expecting { ...</code> 意味着什么?
</h3>

<div>
<p>
在Go语言里，我们不能在任意的位置打断一个代码行。
关于细节请阅读<a href="line-break-rules.html">Go代码的断行规则 </a>。
概括来说，根据这些规则，仅仅在开括号之前断行是不行的。
</p>

例如，下列代码片段

<pre class="line-numbers"><code class="language-go">if true
{
}

for i := 0; i < 10; i++
{
}

var _ = []int
{
	1, 2, 3
}
</code></pre>

将会被解释成

<pre class="line-numbers"><code class="language-go">if true;
{
}

for i := 0; i < 10; i++;
{
}

var _ = []int;
{
	1, 2, 3;
}
</code></pre>

Go编译器将报告每个开括号<code>{</code>的错误。
为避免这些错误，我们需要重写上述代码如下。

<pre class="line-numbers"><code class="language-go">if true {
}

for i := 0; i < 10; i++ {
}

var _ = []int {
	1, 2, 3,
}
</code></pre>

</div>

<p class="anchor" id="error-declared-not-used"></p>
<h3>
	编译器错误信息 <code>declared and not used</code> 意味着什么?
</h3>

<div>
<p>
对于标准的Go编译器，在本地代码块中声明的每一个变量必须至少一次被用作RHS(right-hand side)值。
</p>

因此，下列代码在编译时候会失败。

<pre class="line-numbers"><code class="language-go">func f(x bool) {
	var y = 1 // y declared and not used
	if x {
		y = 2
	}
}
</code></pre>

<!--
exception: https://github.com/golang/go/issues/8560
-->

</div>


<p class="anchor" id="map-iteration-order"></p>
<h3>
	Go运行时是否维护maps的迭代顺序？
</h3>

<p>
不。<a href="https://golang.org/ref/spec#For_range">Go 1 specification</a>提到不会指定maps的迭代顺序，
也不能保证从一个迭代到下一个迭代都是相同的。对于标准的Go编译器，map的迭代顺序是随机的。
如果你需要一个稳定的map迭代顺序，那么你就需要自己维护顺序。
更多信息请阅读<a href="https://blog.golang.org/go-maps-in-action#TOC_7.">Go maps in action</a>。
</p>

<p class="anchor" id="compiler-field-padding"></p>
<h3>
	Go编译器是否会进行填充以确保结构体类型的字段对齐？
</h3>

<p>
至少对于标准的Go编译器和gccgo，答案是肯定的。
填充取决于操作系统和编译器。
</p>

<div>
例如：
<pre class="line-numbers"><code class="language-go">type T1 struct {
	a int8
	// 7 bytes padded on AMD64 OS and pad 3 bytes padded on i386 OS here
	b int64
	c int16
	// 6 bytes padded on AMD64 OS and pad 2 bytes padded on i386 OS here
}

type T2 struct {
	a int8
	// 1 byte padded on both AMD64 and i386 OS here
	c int16
	// 4 bytes padded on AMD64 OS here. No padding on i386 OS
	b int64
}
</code></pre>
<p>
<code>T1.b</code>值的地址在内存中必须在AMD64的操作系统上对齐为8个字节，在i386的操作系统上则对齐为4个字节；
这就是为什么在<code>T1.a</code>之后Go编译器在AMD64的操作系统上需要填充7个字节，而在i386的操作系统上则要填充3个字节。
</p>
<p>
Go规范 <a href="https://golang.org/ref/spec#Size_and_alignment_guarantees">为类型对齐的一些保证</a>。
其中一个就是结构体类型的对齐是其字段类型的最大对齐。
因此<code>T1</code>在AMD64操作系统上也是8个字节对齐的，在i386上也是4个字节对齐的（与<code>T1.b</code>, <code>int64</code>的类型类似），
并且标准的Go编译器会确保类型的值的大小是该类型的对齐保证的倍数，这也是为什么在<code>T1</code>的值的结尾处：AMD64的操作系统上需要填充6个字节，i386的操作系统上需要填充2个字节。
</p>
<p>
结构体内字段的顺序会影响填充，并且填充之后会影响结构体的大小。
在AMD64的操作系统上，<code>T1</code>的值的大小是24，但是<code>T2</code>的值的大小是16。
</p>
<p>
Go编译器将不会重新排列结构体的字段来最小化结构体值的大小。
因为这样做会导致意想不到的结果。
然而，程序员可以手工重新排序字段来实现最小化填充。
</p>
</div>

<p class="anchor" id="final-zero-size-field"></p>
<h3>
	为什么结构体中零大小类型的最后一个字段有时会影响结构体的大小？
</h3>

<p><i>
(This is not a Go spec rule. It is a compiler specified implementation.
Here is the compiler is the standard Go compiler.
Please view <a href="https://github.com/golang/go/issues/9401">issue#9401</a> for details.)
（这个不是一个Go语言规范里的规则。而是一个编译器的实现规范。这里的编译器是标准的Go编译器。
关于细节请参考 <a href="https://github.com/golang/go/issues/9401">issue#9401</a>）
</i></p>

在现在标准的Go运行时实现里，如果一个内存块被至少一个活跃的指针引用，那么这个内存块将不会被视作垃圾并且也不会被回收。
一个可寻址结构值的所有字段都可以取地址。
如果非零大小的结构体的最后一个字段的大小是零，那么取结构体最后一个字段的地址将会返回一个超出了为结构体分配的内存块的地址。
这个返回的地址可以
<ul>
<li>
	指向另一个被分配的内存块。如果一个活跃指针存储在这个地址，它将阻止垃圾收集器回收其他分配的内存块，导致内存泄漏。
</li>
<li>
	指向一个未分配的内存区域。这将导致垃圾收集器重新收集未分配的内存，并可能导致程序崩溃。
</li>
</ul>

<p>
为避免上述问题，标准的Go编译器会确保取非零大小的结构体的最后一个字段的地址时，绝对不会返回超出分配给结构体的内存块的地址。
Go标准编译器通过在需要时在结构体最后的零大小字段之前填充一些字节来实现这一点。
</p>

<p>
如果一个结构体的全部字段的类型都是零大小的(因此整个结构体也是零大小类型的)，那么就不需要在结构体里填充字节，因为Go标准编译器会专门处理零大小的类型。
</p>

<div>
例如:
<pre class="line-numbers"><code class="language-go">package main

import (
	"unsafe"
	"fmt"
)

func main() {
	type T1 struct {
		a struct{}
		x int64
	}
	fmt.Println(unsafe.Sizeof(T1{})) // 8
	
	type T2 struct {
		x int64
		a struct{}
	}
	fmt.Println(unsafe.Sizeof(T2{})) // 16
}
</code></pre>
</div>

<p class="anchor" id="new-function"></p>
<h3>
	<code>new(T)</code> 是 <code>var t T; (&t)</code>的语法糖吗？
</h3>

<p>
基本上你可以怎么认为。
通过<code>new</code>分配的内存块可以在栈上，也可以在堆上。
两者之间会有一些微妙的差别，取决于编译器的实现。
</p>

<p class="anchor" id="fatal-error-deadlock"></p>
<h3>
	运行时错误信息 <code>all goroutines are asleep - deadlock</code> 意味着什么?
</h3>

<p>
词语<b><i>asleep</i></b>在这里用的并不准确，实际上它的意思是<b><i>处于阻塞状态</i></b>。
因为一个阻塞的goroutine只能被另一个goroutine解除阻塞，如果程序中所有的goroutines都进入阻塞状态，
那么它们将永远处于阻塞状态。这意味着程序将死锁。
一个正常运行的程序永远不会被认为是死锁的，因此标准Go运行时会使程序崩溃并且退出。
</p>

<p class="anchor" id="64-bit-alignment"></p>
<h3>
	64位变量和结构体字段是否保证64位对齐以便可以原子地访问它们？
</h3>

<p>
传给<code>sync/atomic</code>包里的64位函数的地址必须是64位对齐的，否则调用这些函数就会在运行时导致代码崩溃（panic）。
<p>
For the standard Go compiler and gccgo compiler,
on 64-bit architectures, 64-bit integers are guaranteed to be 64-bit aligned.
So they can be always accessed atomically without any problems.
对于标准的Go编译器和gccgo编译器，在64位架构下，64位整数会保证以64位对齐。
所以它们总是可以以原子的方式访问而不发生任何问题。
</p>

<p>
On 32-bit architectures, 64-bit integers are only guaranteed to be 32-bit aligned.
So accessing many 64-bit integers atomically may cause panics.
However, there are some ways to guarantee some 64-bit integers to be elied upon to be 64-bit aligned.
Please read <a href="memory-layout.html">memory layouts in Go</a> for details.
在32位架构下，64位整数仅保证以32位对齐。
所以原子的访问许多64位整数会导致代码崩溃（panics）。
但是，有一些方法可以保证某些64位整数被省略，从而实现64位对齐。
关于细节请阅读<a href="memory-layout.html">Go的内存布局</a>。 
</p>


<!--
<div>
For Go programs run on 32-bit OSes, there is no the universal guarantee.
But following 64-bit words are guaranteed to be able to be accessed atomically:
对于运行中32位操作系统上的Go程序，这不是普遍的保证。
但是下述64位的词会保证以原子地方式访问：
<ul>
<li>allocated 64-bit words.</li>
<li>the first field in an allocated struct if the field is a 64-bit word.</li>
<li>the first word in the first elements of an allocated array if the word is 64-bit.</li>
</ul>
</div>

<p>
Here, an <b><i>allocated</i></b> value means the address of the value is
the start address of the memory block the value locates at.
In other words, the value is placed at the beginning of the memory block it locates at.
</p>

<p>
A qualified Go compiler should promise that
all elements in an array/slice can also be accessed atomically
if one element in the array/slice can be accessed atomically
and the element type is a 64-bit word type,
though the official documentation doesn't make this guarantee.
</p>

<div>
Example:
<pre class="line-numbers"><code class="language-go">package main

import (
	"sync/atomic"
)

type T struct {
	a uint64
	b bool
	c int64
}

type V struct {
	d byte
	t T // t.a is not the first field in V.
}

var x int64
var y [3]uint64
var z = make([]int64, 5)
var t T

var v V

func main() {
	var x2 int64
	var y2 [3]uint64
	var z2 = make([]int64, 5)
	var t2 T
	
	var v2 = new(V)
	
	// following lines are guaranteed to be safe on
	// both 64-bit and 32-bit OS.
	atomic.LoadInt64(&x)
	atomic.LoadUint64(&y[1])
	atomic.LoadInt64(&z[2])
	atomic.LoadUint64(&t.a)
	
	atomic.LoadInt64(&x2)
	atomic.LoadUint64(&y2[1])
	atomic.LoadInt64(&z2[2])
	atomic.LoadUint64(&t2.a)
	
	// the following two lines are safe on 64-bit OS
	// but may be panic on 32-bit OS	
	atomic.LoadUint64(&v.t.a)
	atomic.LoadUint64(&v2.t.a)
}
</code></pre>

</div>
-->

<p class="anchor" id="atomical-assignment"></p>
<h3>
	赋值是原子操作吗？
</h3>

<p>
在标准的Go编译器里并不是，即使所赋值的大小是一个单词。
</p>

<p>
关于细节请阅读<a href="https://golang.org/doc/faq#What_operations_are_atomic_What_about_mutexes">the official question</a>。
</p>

<p class="anchor" id="zero-values-zero-bytes"></p>
<h3>
	是否每一个零值都是由内存中的零比特序列组成的？
</h3>

<div>
<p>
For most types, this is true.
In fact, this is compiler dependent.
For example, for the standard Go runtime,
the statement is wrong for some zero values of string types.
对于大部分类型，肯定的。
不过事实上，也依赖于编译器。
例如，对于标准的Go运行时，对于某些字符串类型的零值，这个声明是错误的。
</p>

举证如下:
<pre class="line-numbers"><code class="language-go">package main

import (
	"unsafe"
	"fmt"
)

func main() {
	var s1 string
	fmt.Println(s1 == "") // true
	fmt.Println(*(*uintptr)(unsafe.Pointer(&s1))) // 0
	var s2 = "abc"[0:0]
	fmt.Println(s2 == "") // true
	fmt.Println(*(*uintptr)(unsafe.Pointer(&s2))) // 4869856
	fmt.Println(s1 == s2) // true
}
</code></pre>
</div>

<p>
相反的，对于标准Go编译器已经支持的全部处理器/架构，如果一个值的所有字节都是零，那么这个值必须是这个类型的零值。
然而，Go规范并没有保证这一点。
据说在一些比较老的处理器上，nil指针在内存中不是零。
</p>

<p class="anchor" id="function-inline"></p>
<h3>
	标准的Go编译器是否支持内联函数？
</h3>

<p>
是的，标准的Go编译器支持内联函数。
编译器会自动的内联短小的叶子函数。
叶子函数即不包含函数调用的函数。
特定的内联规则可能在不同版本之间发生变化。
</p>

<div>
目前（Go 1.11），对于标准Go编译器，
<ul>
<li>没有显示的方式来在用户程序里指定哪些函数应该内联。</li>
<li>尽管构建参数<code>-gcflags "-l"</code>可以阻止任何函数被内联，
	但是并没有正式的方式来避免在用户程序中内联指定的函数。
	有以下两种非正式方式（不过对于未来的Go标准编译器版本，它们都将失效）来时实现这一点：
	<ul>
	<li>你可以在函数声明前增加一行<code>//go:noinline</code> 指令来避免这个函数被内联。</li>
	<li><stroke>由于包含循环块的函数不会内联，所以你可以再函数里增加一个空循环 <code>for false {}</code>来避免该函数被内联<stroke>
		(但是这个方法从<a href="https://github.com/golang/go/issues/14768">since Go 1.12</a>以后不再有效.)
	</li>
	</ul>
</li>
</ul>
</div>

<!-- 标准库  -->

<p class="anchor" id="pointer-atomic"></p>
<h3>
	如何原子地操作指针的值？
</h3>

<div>
例如:
<pre class="line-numbers"><code class="language-go">import (
	"unsafe"
	"sync/atomic"
)

type T int // just a demo

var p *T

func demo(newP *T) {
	// load
	var _ = (*T)(atomic.LoadPointer(
		(*unsafe.Pointer)(unsafe.Pointer(&p)),
		))
	
	// store
	atomic.StorePointer(
		(*unsafe.Pointer)(unsafe.Pointer(&p)),
		unsafe.Pointer(newP),
		)
	
	
	// swap
	var oldP = (*T)(atomic.SwapPointer(
		(*unsafe.Pointer)(unsafe.Pointer(&p)),
		unsafe.Pointer(newP),
		))
	
	// compare and swap
	var swapped = atomic.CompareAndSwapPointer(
		(*unsafe.Pointer)(unsafe.Pointer(&p)),
		unsafe.Pointer(oldP),
		unsafe.Pointer(newP),
		)
	
	_ = swapped
}
</code></pre>
是的，目前使用指针原子函数显得十分冗长。
</div>

<p class="anchor" id="get-days-of-month"></p>
<h3>
	如何使用尽可能短的代码行数来获取任意月份的天数？
</h3>

<div>
Assume the input year is a nature year and the input month is also a nature month (January is 1).
假设输入的年份是一个自然年，并且输入的月份也是一个自然月（1代表1月）。
<pre class="line-numbers"><code class="language-go">days := time.Date(year, month+1, 0, 0, 0, 0, 0, time.UTC).Day()
</code></pre>
对于Go时间APIs，自然月的范围是［1，12］且每个月的起始日是1。
那么，<code>y</code>年的<code>m</code>月的起始时间就是<code>time.Date(y, m, 1, 0, 0, 0, 0, time.UTC)</code>。
<p>
传递给<code>time.Date</code>函数的参数可以超出它们的正常范围并且在转化期间进行规范化。
例如，1月32日会被转换成2月1日。
</p>

以下是一些Go语言里的日期使用示例：
<pre class="line-numbers"><code class="language-go">package main

import (
	"time"
	"fmt"
)

func main() {
	// 2017-02-01 00:00:00 +0000 UTC
	fmt.Println(time.Date(2017, 1, 32, 0, 0, 0, 0, time.UTC))
	
	// 2017-01-31 23:59:59.999999999 +0000 UTC
	fmt.Println(time.Date(2017, 1, 32, 0, 0, 0, -1, time.UTC))
	
	// 2017-01-31 00:00:00 +0000 UTC
	fmt.Println(time.Date(2017, 2, 0, 0, 0, 0, 0, time.UTC))
	
	// 2016-12-31 00:00:00 +0000 UTC
	fmt.Println(time.Date(2016, 13, 0, 0, 0, 0, 0, time.UTC))
	
	// 2017-02-01 00:00:00 +0000 UTC
	fmt.Println(time.Date(2016, 13, 32, 0, 0, 0, 0, time.UTC))
}
</code></pre>
</div>

<p class="anchor" id="time-sleep-after"></p>
<h3>
	函数调用<code>time.Sleep(d)</code>和管道接收<code>&lt;-time.After(d)</code>操作之间有何区别？
</h3>

<p>
两者都会将当前的goroutine执行暂停一段时间。
区别在于<code>time.Sleep(d)</code>函数调用将使当前的goroutine进入睡眠(这不是一个goroutine状态)，
但是goroutine状态仍旧停留在<a href="control-flows-more.html#states-of-goroutine">运行状态</a>；
而管道接收到<code>&lt;-time.After(d)</code>操作将使得当前goroutine进入阻塞状态。
</p>

<p class="anchor" id="finalizers"></p>
<h3>
	可以使用finalizers作为对象的析构函数吗？
</h3>

<p>
在Go程序里，我们可以通过使用<code>runtime.SetFinalizer</code>函数来给一个对象设置finalizer
函数。finalizer函数将在对象被垃圾回收之前调用。
但是finalizer从来不打算用做对象的析构函数。通过<code>runtime.SetFinalizer</code> 设置的finalizers
并不保证被运行。因此你不应该依赖finalizers保证程序的正确性。
</p>

<p>
finalizers的主要用途是为了函数库的维护者能够获得额外的努力来修复因为函数库使用者不当使用而导致的破坏。
例如，在一段程序里，如果我们使用了<code>os.Open</code>来打开多个文件但是在使用完成后并未关闭，
那么程序会保持多个文件的描述符直到程序退出。这会导致资源泄漏。为了避免程序报纸多个文件的描述符，
<code>os</code> 包的维护者将会在每个被创建的<code>os.File</code>对象里设置finalizers。
finalizers将关闭存储在<code>os.File</code>对象里的文件描述符。它们只是用来使资源泄漏的范围尽可能小。
</p>

<p>
有时候，为避免一个finalizer在对象里被过早的调用，我们可以使用函数
<a href="https://golang.org/pkg/runtime/#KeepAlive">runtime.KeepAlive</a>来防止对象
过早被垃圾回收。
</p>

<!-- to add best practices and more cases where finalizer doesn't work. -->

<p>
请记住，有一些finalizers永远不会被调用，并且有时候不当的设置finalizers会防止对象被垃圾回收。
关于更多细节请阅读<a href="https://golang.org/pkg/runtime/#SetFinalizer">runtime.SetFinalizer</a>函数文档。
</p>

<p class="anchor" id="trim"></p>
<h3>
	在<code>strings</code>和<code>bytes</code>标准包里调用<code>TrimLeft</code>和<code>TrimRight</code>函数经常会返回不可预知的结果，这是这些函数实现的bugs吗
</h3>

<p>
哈哈，可能的却是实现的bugs，但是目前还没得到证实。
如果返回的结果是不可预知的，那么更有可能的事你的期望是不正确的。
</p>

<div>
标准包 <code>strings</code> 和 <code>bytes</code>里有多个修剪（trim）函数。
那些函数可以被分类为以下两个组：
<ol>
<li>
	<code>Trim</code>, <code>TrimLeft</code>, <code>TrimRight</code>, <code>TrimSpace</code>, <code>TrimFunc</code>, <code>TrimLeftFunc</code>, <code>TrimRightFunc</code>.
	这些函数将修剪所有满足指定或隐含条件的utf -8编码的Unicode编码点(即符文)。（<code>TrimSpace</code> 隐含了修剪所有类型的空格符。）
	函数将检查每个前导或后导符文，直到其中有一个符文不满足指定或隐含的条件。
</li>
<li>
	<code>TrimPrefix</code>, <code>TrimSuffix</code>.
	这两个函数会把前缀或后缀的子字符串（或子片段）作为一个整体来修剪。
</li>
</ol>

<p>
<a href="https://github.com/golang/go/issues/19172">部分</a>
<a href="https://github.com/golang/go/issues/18160">程序员</a>
<a href="https://github.com/golang/go/issues/14657">会</a>
把<code>TrimLeft</code> 和 <code>TrimRight</code>函数当作<code>TrimPrefix</code> 和 <code>TrimSuffix</code>函数
<a href="https://github.com/golang/go/issues/19371">误用</a>。
当然，函数返回的结果很可能不是预期的那样。。
</p>

例如:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"strings"
)

func main() {
	var s = "abaay森z众xbbab"
	fmt.Println(strings.TrimPrefix(s, "ab")) // aay森z众xbbab
	fmt.Println(strings.TrimSuffix(s, "ab")) // abaay森z众xbb
	fmt.Println(strings.TrimLeft(s, "ab"))   // y森z众xbbab
	fmt.Println(strings.TrimRight(s, "ab"))  // abaay森z众x
	fmt.Println(strings.Trim(s, "ab"))       // y森z众x
	fmt.Println(strings.TrimFunc(s, func(r rune) bool {
			return r < 128 // trim all ascii chars
		},
	)) // 森z众
}

</code></pre>
</div>

<p class="anchor" id="fmt-print-println"></p>
<h3>
	函数<code>fmt.Print</code> 和 <code>fmt.Println</code> 的区别是什么？
</h3>

<p>
<code>fmt.Println</code>函数总会在两个相邻的参数之间写入一个空格，然而<code>fmt.Print</code>函数仅当
两个相邻的参数（具体值）都不是字符串类型时才会在两个相邻参数之间写入一个空格。
</p>

<p>
另外一个区别是 <code>fmt.Println</code>函数会在结尾写入一个换行符，但是 <code>fmt.Print</code> 函数不会。
</p>

<p class="anchor" id="log-print-println"></p>
<h3>
	函数<code>log.Print</code> 和函数 <code>log.Println</code> 有什么区别吗?
</h3>

<p>
函数<code>log.Print</code>与<code>log.Println</code>的区别与上一个问题里描述的关于函数<code>fmt.Print</code> 和 
<code>fmt.Println</code>的第一个区别点类似。
</p>

<p>
所有的这两个函数都会在结尾写入一个换行符。
</p>

<p class="anchor" id="fmt-print-synced"></p>
<h3>
	函数<code>fmt.Print</code>, <code>fmt.Println</code> 和 <code>fmt.Printf</code>是同步的吗？
</h3>

<p>
不是，这些函数都不是同步的。
如果有同步的需求，请使用在<code>log</code>标准包里的相应函数来代替。
你可以调用<code>fmt.SetFlags(0)</code>来删除每一个日志行的前缀。
</p>

<p class="anchor" id="print-builtin-fmt-log"></p>
<h3>
内置的<code>print</code>/<code>println</code>函数与标准包<code>fmt</code>和<code>log</code>里相应的打印函数有什么区别？
</h3>

<div>
除了上一个问题里提到的区别之外，这三组函数之间还有一些其他区别。
<ol>
<li>
	内置的<code>print</code>/<code>println</code>函数会写入标准错误。
	<code>fmt</code>标准包里的打印函数会写入标准输出。
	<code>log</code>标准包里的打印函数会默认写入标准错误，然而也可以通过<code>log.SetOutput</code>函数来配置。
	
</li>
<li>
	调用内置的 <code>print</code>/<code>println</code> 函数不能接受数组和结构体参数。
</li>
<li>
	对于复合类型的参数，内置的 <code>print</code>/<code>println</code>函数写入参数
	的底层值部的地址，而标准包<code>fmt</code> 和 <code>log</code>的打印函数会
	写入参数的字面值。

</li>
<li>
	目前（Go 1.11），对于标准的Go编译器，调用内置的<code>print</code>/<code>println</code>
	函数不会使调用参数引用的值转移到堆，而<code>fmt</code> 和 <code>log</code>标准包里
	的打印函数会。 
</li>
<li>
	如果一个参数有 <code>String() string</code>或<code>Error() string</code>方法，那么
	标准包 <code>fmt</code> 和 <code>log</code>里的打印函数在写入参数时会调用这两个方法，而
	内置的 <code>print</code>/<code>println</code>函数则会忽略参数的这些方法。
</li>
<li>
	内置的<code>print</code>/<code>println</code>函数不能保证在未来的Go版本中继续存在。
</li>
</ol>
</div>

<p class="anchor" id="math-crypto-rand"></p>
<h3>
	通过标准包<code>math/rand</code>和<code>crypto/rand</code>生成的随机数之间有什么区别？
</h3>

<p>
通过标准包 <code>math/rand</code>生成的伪随机数对于给定的种子是确定的。
这样生成的随机数不适用于安全敏感的上下文中。出于加密安全目的，我们应该使用由标准包
<code>crypto/rand</code>生成的伪随机数。
</p>

<p class="anchor" id="math-round"></p>
<h3>
	为什么没有<code>math.Round</code> 函数?
</h3>

<p>
<code>math.Round</code>函数是有的，但是从Go 1.10之后才有。
从Go 1.10开始，添加了两个新函数<code>math.Round</code> 和 <code>math.RoundToEven</code>。
</p>

<p>
在Go 1.10之前，关于 <code>math.Round</code>函数是否应该被添加进标准包，经历了很长时候的
<a href="https://github.com/golang/go/issues/4594">争议</a>。 最后，提议被采纳。
</p>

<!-- 类型系统 -->

<p class="anchor" id="uncomparable-types"></p>
<h3>
	哪些类型不支持比较？
</h3>


<div>
下列类型不支持比较：
<ul>
<li>映射(map)</li>
<li>切片(slice)</li>
<li>函数</li>
</li>
<li>
包含不可比较字段的结构体类型
</li>
<li>
具有不可比较元素的数组类型
</li>
</ul>
<p>
不支持比较的类型不能用作映射类型的键类型。
</p>
</div>

<div>
请记住，
<ul>
<li>
尽管映射，切片和函数类型不支持比较，但是它们的值可以与空<code>nil</code> 标识符比较。
</li>
<li>
如果两个接口值的动态类型相同且不可比较，那么在运行时<a href="interface.html#comparison">比较这两个接口的值</a>
会导致崩溃。
</li>
</ul>

<p>
关于为什么映射，切片和函数不支持比较，请阅读Go的官方FAQ中<a href="https://golang.org/doc/faq#map_keys">关于这个问题的解释</a>。
</p>

</div>

<p class="anchor" id="nil-equality"></p>
<h3>
	为什么两个<code>nil</code>值有时候会不相等？
</h3>

<p><i>
（Go官方FAQ中的<a href="https://golang.org/doc/faq#nil_error">这个答案</a>也回答了这个问题。）
</i></p>

<div>
在回答这个问题之前，可以先看看Go的一些事实：
<ul>
<li>
	<code>nil</code> 可以用做很多类型的值（指针，切片，映射，管道，函数以及接口）
</li>
<li>
	<code>nil</code> 的值可能没有类型（untyped）。
</li>
<li>
	一个类型是<code>T</code>的非接口类型的值，可以被转换成接口类型<code>I</code>，
	如果<code>T</code>实现了<code>I</code>。转换之后，非接口类型值的副本将会
	存储在接口类型的值中。
</li>
<li>
	一个接口值存储一个非接口值。
	非接口值被称作接口值的动态值。动态值的类型信息仍然被存储在接口值里。
	动态值的类型被称作接口值的动态类型。
</li>
<li>
	无类型的<code>nil</code>值可以被转换成任意类型的指针，切片，映射，管道，函数以及接口。
</li>
<li>
	当一个无类型的 <code>nil</code> 值被存储在接口类型值里的时候，这个接口值就没有动态类型。
</li>
<li>
	如果两个非接口值是可比较的（在编译时和运行时），那么它们必须相等。
</li>
<li>
	如果一个接口值和一个非接口值是可比较的（在编译时和运行时），那么非接口值在比较前会被转换成接口值的类型。
	因此比较一个接口值和一个非接口值是否想等是在比较两个接口值。
</li>
<li>
	如果两个接口值是可比较的（在编译时和运行时），那么仅当它们有相同的动态类型并且其动态值相等的时候它们才相等。
</li>
</ul>

从这些事实中，我们可以得到：
<ul>
<li>
	两个动态值都是 <code>nil</code>的接口值，如果它们的动态值不同
	（或者一个具有动态类型而另一个没有），则不相等。

</li>
<li>
	一个动态值是 <code>nil</code>的接口值和一个非接口的 <code>nil</code>值，
	如果接口值的动态类型不是非接口<code>nil</code>值的类型，则不相等。
</li>
</ul>

<p>
关于更详细的解释请阅读<a href="interface.html">interfaces in Go</a>和
<a href="nil.html">nils in Go</a>。
</p>

示例如下：:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	var pi *int = nil
	var pb *bool = nil
	var x interface{} = pi
	var y interface{} = pb
	var z interface{} = nil
	
	fmt.Println(x == y)   // false
	fmt.Println(x == nil) // false
	fmt.Println(y == nil) // false
	fmt.Println(x == z)   // false
	fmt.Println(y == z)   // false
}
</code></pre>
</div>

<p class="anchor" id="slice-conversion"></p>
<h3>
	为什么类型 <code>[]T1</code> 和 <code>[]T2</code>没有共享相同底层类型，即使不同的类型<code>T1</code> 和 <code>T2</code>共享相同的底层类型？
</h3>

<p><i>
（不久前，Go官方FAQ也增加了<a href="https://golang.org/doc/faq#convert_slice_with_same_underlying_type">一个相似问题</a>）
</i></p>

<p>
在Go语言中，仅当两个切片类型共享相同的<a href="type-system-overview.html#underlying-type">底层类型</a>时，
一个切片类型才可以转换成另一个切片类型而不需要使用<code>unsafe</code>机制
（<a href="value-conversions-assignments-and-comparisons.html">这个章节</a>列举了全部的值转换规则）。
</p>

<p>
未命名复合类型的底层类型是复合类型本身。
所以即便两个类型<code>T1</code> 和 <code>T2</code> 共享相同的底层类型，类型<code>[]T1</code> 和 <code>[]T2</code>也
依然是不同的类型，因此它们的底层类型也是不同的，这意味着其中一个的值不能转换为另一个。
</p>

<div>
底层类型<code>[]T1</code> 和 <code>[]T2</code>不同的原因是：
<ul>
<li>把<code>[]T1</code> 和 <code>[]T2</code>的值相互转换的需求在实践中并不强烈</li>
<li>是<a href="type-system-overview.html#underlying-type">底层类型追踪规则</a> 更加简单.</li>
</ul>
</div>

<p>
同样的原因也适用于其它复合类型。
例如：类型<code>map[T]T1</code> 和 <code>map[T]T2</code>同样不共享相同的底层类型，即便<code>T1</code> 和 <code>T2</code>共享相同的底层类型。
</p>

<div>
类型<code>[]T1</code>的值时候有可能通过使用<code>unsafe</code>机制转换成<code>[]T2</code>的，但是一般不建议这么做：
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"unsafe"
)

func main() {
	type MyInt int
	
	var a = []int{7, 8, 9}
	var b = *(*[]MyInt)(unsafe.Pointer(&a))
	b[0]= 123
	fmt.Println(a) // [123 8 9]
	fmt.Println(b) // [123 8 9]
	fmt.Printf("%T \n", a) // []int
	fmt.Printf("%T \n", b) // []main.MyInt
}
</code></pre>
</div>

<p class="anchor" id="unaddressable-values"></p>
<h3>
	哪些值可以取地址，哪些值不可以取地址？
</h3>

<div>
以下的值不可以取地址：
<ul>
<li>字节字符串</li>
<li>映射元素</li>
<li>接口值的动态值（通过类型断言暴露出来）</li>
<li>常量值</li>
<li>字面值</li>
<li>包级别函数</li>
<li>方法（用做函数值）</li>
<li>中间值
	<ul>
	<li>函数调用</li>
	<li>显示值转换</li>
	<li>各种操作，不包含指针解引用（dereference）操作，但是包含：
		<ul>
		<li>管道接收操作</li>
		<li>子字符串操作</li>
		<li>子切片操作</li>
		<li>加法，减法，乘法，以及除法，等等。</li>
		</ul>
	</li>
	</ul>
</li>
</ul>
</div>

<div class="alert alert-success">
请注意，<code>&T{}</code>在Go里并不是语法糖。
而只是<code>tmp := T{}; (&tmp)</code>的一个简单形式。
所以<code>&T{}</code>是合法的并不代表<code>T{}</code>可以取地址。
</div>
<p></p>

<div>
以下的值可以取地址：
<ul>
<li>变量</li>
<li>可寻址结构体的字段</li>
<li>可寻址数组的元素</li>
<li>任意切片的元素（无论切片是可寻址或不可寻址的</li>
<li>指针解引用（dereference）操作</li>
</ul>
</div>

<p class="anchor" id="maps-are-unaddressable"></p>
<h3>
	为什么映射的元素不可取地址？
</h3>

<p>
主要原因是使映射的元素可以寻址意味着映射的元素在其声明周期中必须不可变。
这阻碍了Go编译器在实现映射时使用更加有效率的算法。
对于标准的Go编译器，映射元素的内部地址可以在运行时改变。
</p>

<p class="anchor" id="slice-elements-always-addressable"></p>
<h3>
	为什么非空切片的元素总是可取地址，即便切片是不可取地址的？
</h3>

<div>
切片的内部类型是一个结构体，类似于
<pre class="line-numbers"><code class="language-go">struct {
	elements unsafe.Pointer
	length   int
	capacity int
}
</code></pre>
<p>
每一个切片间接引用一个元素序列。
尽管一个非空切片是不可取地址的，它的内部元素序列必须是可取地址的。
取一个切片的元素地址事实上是取内部数组的元素地址。
这就是为什么不可取地址的非空切片的元素是可以取地址的。
</p>
</div>

<p>
基于同样的原因，在不可取地址的字符串上的子字符串的操作也总是可以编译通过的
（使用标准Go编译器）。
但是，我不能确定这是否是Go规范所保证的。
</p>

<p class="anchor" id="method-set-relation"></p>
<h3>
	对任意的非指针，非接口定义类型<code>T</code>，为什么<code>*T</code>的方法集总是<code>T</code>的方法集的超集，但是反之不然？
</h3>

<div>
在Go语言中，为了方便，
<ul>
<li>
	一个<code>T</code>类型值可以调用定义在<code>*T</code>类型的方法，仅当<code>*T</code>的值是可寻址的。
	编译器在调用指针方法前，会自动取<code>T</code>值的地址。
	因为不是任何类型<code>T</code>都是可寻址的，也不是任何类型<code>T</code>的值都能够调用类型<code>*T</code>上定于的方法。
	<div>这种便利只是一个语法糖，而不是一种固有的规则。</div>
</li>
<li>
	这是因为解引用指针值总是合法的。
	<div>这种便利不仅仅是一个语法糖，而且是一种固有的规则。</div>
</li>
</ul>
<p>
所以很合理的是 <code>*T</code>的方法集总是<code>T</code>方法集的超集，但反之不然。
</p>
</div>

<div>
事实上，你可以认为每一个类型 <code>T</code>上定义的方法，在类型<code>*T</code>上都自动定义了具有相同名称和相同签名的隐式方法：
<pre class="line-numbers"><code class="language-go">func (t T) MethodX(param0 ParamType0, ...) (result0 ResultType0, ...) {
	...
}

// An implicit method of *T is automatically defined as
func (pt *T) MethodX(param0 ParamType0, ...) (result0 ResultType0, ...) {
	return (*pt).MethodX(param0, ...)
}
</code></pre>

<p>
如果在类型<code>*T</code>上定义了一个方法，那么在 <code>T</code>上就再也不能定义具有相同方法名称的方法了。
这是另一种解释为什么 <code>*T</code>的方法集总是<code>T</code>方法集的超集，但反之不然。	
</p>
</div>

<p><i>
（更多解释请阅读Go官方FAQ中的 <a href="https://golang.org/doc/faq#different_method_sets">这个答案</a>）
</i></p>

<p class="anchor" id="types-can-have-methods"></p>
<h3>
	我们可以为哪些类型实现方法？
</h3>

<p>
关于细节请阅读 <a href="method.html">Go的方法</a>。 
</p>

<p class="anchor" id="declare-immutables"></p>
<h3>
	在Go里如何声明不可变的值？
</h3>

<div>
如下是三种<b><i>不可变值</i></b>的定义： 
<ol>
<li>没有地址的值（所以它们不可以寻址）。</li>
<li>有地址但是不可以寻址的值（它们的地址在语法上不允许取得）。</li>
<li>可寻址但不允许在语法中修改其值的值。</li>
</ol>

<p>
在Go语言中，直到现在（Go 1.11），都没有值可以满足第三种定义。
换言之，第三种定义并不支持。
</p>

<p>
常量值满足第一种定义。
</p>

<p>
方法喝包级别的函数可以同样视作已声明的不可变值。
它们满足第二种定义。
字符串元素（字节）和映射元素同样满足第二种定义。
</p>

<p>
在Go中没有办法声明其他自定义的不可变命名变量。
</p>
</div>

<p class="anchor" id="set-container-type"></p>
<h3>
	为什么没有内置的 <code>set</code> 容器类型？
</h3>

<div>
集合(Set)只是映射，但不关心元素值。
在Go语言里，<code>map[Tkey]struct{}</code>经常被用做一个集合类型。
</div>

<p class="anchor" id="byte-rune-slice-string"></p>
<h3>
	什么是字节？什么是符文？
	如何将 <code>[]byte</code> 和 <code>[]rune</code>的值转换为字符串？
</h3>

<p>
在Go语言里， <code>字节</code>是<code>uint8</code>类型的一个别名。
换言之，<code>字节</code> 和 <code>uint8</code>是相同的类型。
同样类似的关系是<code>符文</code>和<code>int32</code>。
</p>

<p>
一个<code>符文</code>通常被用来存储一个Unicode断点。
</p>

<div>
<code>[]byte</code> 和 <code>[]rune</code>的值可以间接但是显式的转换成 <code>字符串</code>，反之亦然。
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	var s0 = "Go"
	
	var bs = []byte(s0)
	var s1 = string(bs)
	
	var rs = []rune(s0)
	var s2 = string(rs)
	
	fmt.Println(s0 == s1) // true
	fmt.Println(s0 == s2) // true
}
</code></pre>
</div>

<p>
更多关于字符串的信息，请阅读<a href="string.html">Go的字符串</a>。
</p>

<!-- 其它 -->

<p class="anchor" id="about-iota"></p>
<h3>
	<code>iota</code>是什么意思？
</h3>

<div>
Iota是希腊字母表中的第九个字母。
在Go语言中，<code>iota</code>用于数字常量声明。
在每一个常量组里，其值在该常量声明组的第<b><i>N</i></b>个常量规范中为<code>N</code>。
</div>

<p class="anchor" id="check-if-channels-closed"></p>
<h3>
	为什么没有内置的<code>closed</code>函数检查管道是否关闭？
</h3>

<p>
原因是这种功能的实用性非常有限。
对此类函数的调用的返回结果可能无法反映输入管道的最新状态。
所以依靠返回结果来做决定不是一个好主意。
</p>

<p>
如果你需要这种函数，那么你可以花时间自己写一个。
关于如何写<code>closed</code>函数以及如何避免使用这样的函数，请参阅<a href="channel-closing.html">这个章节</a>。
</p>

<p class="anchor" id="return-local-pointers"></p>
<h3>
	返回本地变量指针的函数是否安全？
</h3>

<p>
是的，在Go里是绝对安全的。
</p>

<p>
支持堆栈的Go编译器将进行escape分析。
对于标准的Go编译器，如果escape分析器认为内存块肯定只会在当前函数调用中使用，就会在堆上分配内存块，
反之，就会在堆上分配内存块。
</p>

<p class="anchor" id="gopher"></p>
<h3>
	单词<b><i>gopher</i></b>在Go社区代表什么？
</h3>

<p>
这个昵称源自于Go语言采用<a href="https://blog.golang.org/gopher">一个卡通的小田鼠(gopher)</a>作为吉祥物。
顺便说一下，这个卡通的田鼠是由<i>Renee French</i>设计的，她是Go项目负责人<i>Rob Pike</i>的妻子。
</p>


<!--

why left side of := must be pure identifiers?
* s, s[0] = []int{1, 2}, 1. The "s[0]" is an element of an old slice or the new slice?

why fmt.Print function makes argument escape to heap.

todo: add related go-nuts/issue links in each question.

todo: also index official faq questions.

is it possible to recover out of memory error?
* https://github.com/golang/go/issues/14162
* https://github.com/golang/go/issues/16843
* https://groups.google.com/forum/#!topic/golang-dev/wUEWhk2jtHM
* https://github.com/golang/go/blob/master/src/runtime/HACKING.md#error-handling-and-reporting

time.Format, what do 01 02 03 04 05 06 07 mean?

Why json marshal no output: fields are not exported.

in go, size type is int, not uint, why?

why Go doesn't support loop import like C++ and Java?
just a tradeoff, one of many in Go.

Why is there not a function to get the undrlying type of a type
https://groups.google.com/forum/#!searchin/golang-nuts/reflect$3A$20get$20underlying$20type|sort:relevance/golang-nuts/BJEuegjQtEA/q2S3b6JxY1MJ

https://www.reddit.com/r/golang/comments/8m4xrh/do_linux_golang_binaries_depend_on_libc/

Why type assertion with ok fail panic?
* while the design of Go tries to be consistent in a big view, there are really some inconsistencies at some details.
* history reason ...

why defined pointer type has no and can't own methods.

Why fallthrough not allowed in select and type-switch?
https://github.com/golang/go/issues/25676#issuecomment-393734800
(it is feasible if the next branch is defailt or no variables are declared,
but for consistentcy, ...)

why break and fallthrought are not allowed in type switcn and select

* why non-exported fileds can be listed through reflect?
  * for a non-exported fileds can have exported fileds.
    Otherwise, there are no ways to listed the exported fileds.

-->

