<h1>Go 技巧 101</h1>

索引

<ul>
<li>
	<a href="#force-to-use-keyed-struct-literals">如何强制包的使用者用结构体复合字面值作为字段名字？</a>
</li>
<li>
	<a href="#make-struct-type-uncomparable">如何使得结构体类型不可比较？</a>
</li>
<li>
	<a href="#dont-use-assignments-with-expression-dependencies">不要使用表达式之间依赖关系的值赋值。</a>
</li>
<li>
	<a href="#simulate-loop-from-0-to-n">如何以其它语法模拟<code>for i in 0..N</code>？</a>
</li>
<li>
	<a href="#reset-pointers-for-dead-elements">我们应该重置元素slots中的指针，这些指针在所有类型的切片操作中被释放来避免内存泄漏，如果我们不能确定释放的元素slots以后是否会被重用。</a>
</li>
<li>
	<a href="#avoid-copying-values-of-some-types">在标准包里的一些类型的值不期望被复制。</a>
</li>
<li>
	<a href="#memclr">我们可以使用memclr优化来重置一些在数组或者切片中连续的元素。</a>
</li>
<li>
	<a href="#check-method-existance">如何在不导入<code>refect</code>包的情况下检查一个值是否有方法。</a>
</li>
<li>
	<a href="#clone-slice-efficiently-and-perfectly">如何高效且完美的克隆一个切片？</a>
</li>
<li>
	<a href="#use-three-index-subslice-form">我们在部分场景下必须使用三索引子切片。</a>
</li>
<li>
	<a href="#execute-deferred-calls-earlier">使用匿名函数来使部分defered函数调用尽早执行。</a>
</li>
<li>
	<a href="#assert-implementation">确保并显示自定义类型实现了指定的接口类型。</a>
</li>
<li>
	<a href="#assert-at-compile-time">一些编译时断言技巧。</a>
</li>
<li>
	<a href="#declare-max-int-uint">如何声明一个最大的int和uint常量？</a>
</li>
<li>
	<a href="#detect-word-size-at-compile-time">如何在编译时检测原生单词大小？</a>
</li>
<li>
	<a href="#64bit-alignment-guarantee">如何保证64位原子函数调用的第一个指针参数在32位架构上总是64位对齐的？</a>
</li>
<li>
    <a href="#avoid-boxing-large-size-values">避免将大的值装箱到接口值中。</a>
</li>
<li>
	<a href="#make-use-of-bce">使用BCE进行优化（消除边界检查）。</a>
</li>
</ul>






<p class="anchor" id="force-to-use-keyed-struct-literals"></p>
<h3>如何强制包的使用者用结构体复合字面值作为字段名字？</h3>

<div>

<p>
包的开发者可以在一个结构体类型定义里放置一个非导出的零大小的字段，
因此编译器将会禁止包的使用者使用没有字段名字的复合字面值来创建结构体类型。
</p>

例如：

<pre class="line-numbers"><code class="language-go">// foo.go
package foo

type Config struct {
	_    [0]int
	Name string
	Size int
}
</code></pre>

<pre class="line-numbers"><code class="language-go">// main.go
package main

import "foo"

func main() {
	//_ = foo.Config{[0]int{}, "bar", 123} // doesn't compile
	_ = foo.Config{Name: "bar", Size: 123} // compile okay
}
</code></pre>

<p>
</p>

<p>
请尽量不要把零大小的非导出字段作为结构体的最后一个字段，因为<a href="unofficial-faq.html#final-zero-size-field">这样做会扩大结构体类型的大小</a>。
</p>

</div>



<p class="anchor" id="make-struct-type-uncomparable"></p>
<h3>如何使得结构体类型不可比较？</h3>

<div>
有时候，我们想要避免一个自定义的结构体类型被用做一个映射的键类型，
那么我们可以放置一个非导出的零大小的不可比较类型的字段在结构体类型中来使结构体类型不可比较。
例如：

<pre class="line-numbers"><code class="language-go">package main

type T struct {
	Dummy        [0]func()
	AnotherField int
}

var x map[T]int // compile error: invalid map key type T

func main() {
	var a, b T
	_ = a == b // compile error: invalid operation:
}
</code></pre>

<p>
</p>
</div>



<p class="anchor" id="dont-use-assignments-with-expression-dependencies"></p>
<h3>不要使用表达式之间依赖关系的值赋值。</h3>

<div>

<p>
目前(Go 1.11)，在一些多值赋值中<a href="https://github.com/go101/go101/wiki/Some-evaluation-orders-in-multi-value-assignments-are-unspecified">有一些求值顺序是未指定的</a>，并且标准Go编译器和gccgo编译器当涉及多值赋值的表达式之间存在依赖关系时还有<a href="https://github.com/go101/go101/wiki/An-ambiguity-of-%28or-dispute-on%29-the-evaluation-order-of-LHS-%28left-hand-side%29-items-in-a-multi-value-assignment">一些争议和bug</a>。
因此，如果在涉及的表达式之间存在依赖，或者你不确定是否存在依赖关系时，请尝试把多值赋值分拆成多个单值赋值。
</p>

事实上，在部分写得很坏的单值赋值代码中，表达式求值同样是模棱两可的。
例如，下面的程序可能会打印<code>[7 0 9]</code>，<code>[0 8 9]</code>，或者<code>[7 8 9]</code>，依赖于编译器实现。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

var a = &[]int{1, 2, 3}
var i int
func f() int {
	i = 1
	a = &[]int{7, 8, 9}
	return 0
}

func main() {
	// The evaluation order of "a", "i" and "f()" is not specified.
	(*a)[i] = f()
	fmt.Println(*a)
}
</code></pre>

<p>
</p>

<p>
换言之，在值赋值里的一个函数调用不会影响在同样赋值里的非函数调用表达式的求值结果。
关于细节请阅读<a href="evaluation-orders.html">Go里的求值顺序</a>。
</p>

</div>



<p class="anchor" id="simulate-loop-from-0-to-n"></p>
<h3>如何以其它语法模拟<code>for i in 0..N</code>？</h3>

<div>

我们可以在一个元素大小为零的数组或者一个空数组指针上进行遍历来模拟这样的循环。
例如：

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	const N = 5

	for i := range [N]struct{}{} {
		fmt.Println(i)
	}
	for i := range [N][0]int{} {
		fmt.Println(i)
	}
	for i := range (*[N]int)(nil) {
		fmt.Println(i)
	}
}
</code></pre>

</div>



<p class="anchor" id="reset-pointers-for-dead-elements"></p>
<h3>我们应该重置元素slots中的指针，这些指针在所有类型的切片操作中被释放来避免内存泄漏，如果我们不能确定释放的元素slots以后是否会被重用。</h3>

<p>
关于细节请阅读如何<a href="container.html#delete-slice-elements">删除切片元素</a>和<a href="memory-leaking.html#dead-slice-elements">因为未重置丢失的切片元素中的指针而造成的临时性内存泄露</a>。 
</p>



<p class="anchor" id="avoid-copying-values-of-some-types"></p>
<h3>在标准包里的一些类型的值不期望被复制。</h3>

<div>

<p>
<code>bytes.Buffer</code>类型，<code>strings.Builder</code>类型以及在<code>sync</code>标准包里的类型
的值不建议被复制。
（他们确实不建议被复制，尽管在特定情形下复制他们也是没有问题的。）
</p>

<code>strings.Builder</code>的实现会探测到非法的<code>strings.Builder</code>值复制。
一旦这样的复制被发现，就会发生崩溃(panic)。例如：

<pre class="line-numbers"><code class="language-go">package main

import "strings"

func main() {
	var b strings.Builder
	b.WriteString("hello ")
	var b2 = b
	b2.WriteString("world!") // panic here
}
</code></pre>

<p>
</p>

复制标准包<code>sync</code>中类型的值会被Go SDK提供的<code>go vet</code>命令所警告。

<pre class="line-numbers"><code class="language-go">// demo.go
package demo

import "sync"

func f(m sync.Mutex) { // warning: f passes lock by value: sync.Mutex
	m.Lock()
	defer m.Unlock()
	// do something ...
}
</code></pre>

<pre class="output"><code>$ go vet demo.go
./demo.go:5: f passes lock by value: sync.Mutex
</code></pre>

<p>
</p>

<p>
复制<code>bytes.Buffer</code>的值永远不会在运行时被检查到，也不会被<code>go vet</code>命令所检查。
只是要小心不要这样做。

</p>

</div>



<p class="anchor" id="memclr"></p>
<h3>我们可以使用memclr优化来重置一些在数组或者切片中连续的元素。</h3>

<div>

<p>
关于细节请阅读<a href="container.html#memclr"><code>memclr</code>优化</a>。
</p>

</div>



<p class="anchor" id="check-method-existance"></p>
<h3>如何在不导入<code>refect</code>包的情况下检查一个值是否有方法。</h3>

<div>

可以使用下面例子中的方法。
（假设方法需要被检查的原型是<code>M(int) string</code>。）

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

type A int
type B int
func (b B) M(x int) string {
	return fmt.Sprint(b, ": ", x)
}

func check(v interface{}) bool {
	_, has := v.(interface{M(int) string})
	return has
}

func main() {
	var a A = 123
	var b B = 789
	fmt.Println(check(a)) // false
	fmt.Println(check(b)) // true
}
</code></pre>

<p>
</p>

</div>



<p class="anchor" id="clone-slice-efficiently-and-perfectly"></p>
<h3>如何高效且完美的克隆一个切片？</h3>

<div>

<p>
关于细节请阅读<a href="https://github.com/go101/go101/wiki/How-to-perfectly-clone-a-slice%3F">这篇wiki文章</a>和
<a href="https://github.com/go101/go101/wiki/How-to-efficiently-clone-a-slice%3F">这篇wiki文章</a>
</p>

</div>



<p class="anchor" id="use-three-index-subslice-form"></p>
<h3>我们在部分场景下必须使用三索引子切片。</h3>

<div>

假设一个包提供了一个<code>func NewX(...Option) *X</code>函数，并且这个函数的实现将输入选项
与一些内部默认选项合并，那么下面的实现是不推荐的。

<pre class="line-numbers"><code class="language-go">func NewX(opts ...Option) *X {
	options := append(opts, defaultOpts...)
	// Use the merged options to build and return a X.
	// ...
}
</code></pre>

<p>
不推荐上述实现的原因是调用<code>append</code>可能修改参数<code>opts</code>的底层<code>Option</code>序列。
对大多数场景，这是没问题的。
但是对一些特殊场景，这会导致不可预知的结果。
</p>

为避免输入参数的底层<code>Option</code>序列，我们应该使用下面的方法代替之。

<pre class="line-numbers"><code class="language-go">func NewX(opts ...Option) *X {
	options := append(opts[:len(opts):len(opts)], defaultOpts...)
	// Use the merged options to build and return a X.
	// ...
}
</code></pre>

<p>
</p>

<p>
另外一个我们需要使用三索引子切片格式的场景场景在<a href="https://github.com/go101/go101/wiki/The-capacity-of-the-result-byte-%28or-rune%29-slice-of-a-conversion-from-a-string-is-undefined">这篇wiki文章</a>中被提及.
</p>

<p>
使用三索引子切片格式的一个缺点是他们有些冗长。
事实上，我曾经提出了<a href="https://github.com/golang/go/issues/25638">一个建议</a>来减轻冗长，但是它被拒绝了。
</p>

</div>



<p class="anchor" id="execute-deferred-calls-earlier"></p>
<h3>使用匿名函数来使部分defered函数调用尽早执行。</h3>

<div>

<p>
关于细节请阅读<a href="defer-more.html#kind-of-resource-leaking">这篇文章</a>。
</p>

</div>



<p class="anchor" id="assert-implementation"></p>
<h3>确保并显示自定义类型实现了指定的接口类型。</h3>

<div>
<p>
我们可以赋予自定义类型的值给指定接口类型的变量来确保自定义类型实现了指定接口类型，更重要的是，
要显示自定义类型需要实现哪些接口类型。
有时候，用可执行的代码编写文档比用注释写文档好得多。
</p>

<pre class="line-numbers"><code class="language-go">package myreader

import "io"

type MyReader uint16

func NewMyReader() *MyReader {
	var mr MyReader
	return &mr
}

func (mr *MyReader) Read(data []byte) (int, error) {
	switch len(data) {
	default:
		*mr = MyReader(data[0]) << 8 | MyReader(data[1])
		return 2, nil
	case 2:
		*mr = MyReader(data[0]) << 8 | MyReader(data[1])
	case 1:
		*mr = MyReader(data[0])
	case 0:
	}
	return len(data), io.EOF
}

// Any of the following three lines ensures
// type *MyReader implements io.Reader.
var _ io.Reader = NewMyReader()
var _ io.Reader = (*MyReader)(nil)
func _() {_ = io.Reader(nil).(*MyReader)}
</code></pre>

<p>
</p>
</div>



<p class="anchor" id="assert-at-compile-time"></p>
<h3>一些编译时断言技巧。</h3>

<div>
<p>
除了上面提到过的一个，还有更多编译时断言技巧。
</p>

有几种方法保证常量<code>N</code>在编译时不小于另一个常量<code>M</code>：

<pre class="line-numbers"><code class="language-go">// Any of the following lines can guarantee N >= M
func _(x []int) {_ = x[N-M]}
func _(){_ = []int{N-M: 0}}
func _([N-M]int){}
var _ [N-M]int
const _ uint = N-M
type _ [N-M]int

// If M and N are guarenteed to be positive integers.
var _ uint = N/M - 1
</code></pre>

另一个方法是从<a href="https://twitter.com/lukechampine/status/1026695476811390976">@lukechampine</a>借鉴而来。
它利用了<a href="container.html#value-literals">重复的常量键不能出现在同一个复合字面值</a>的规则。

<pre class="line-numbers"><code class="language-go">var _ = map[bool]struct{}{false: struct{}{}, N>=M: struct{}{}}
</code></pre>

上述方法看上去有些冗长，但是更加通用。它可以用来断言一些条件。
它可以不那么冗长，但需要更多(可忽略的)内存:

<pre class="line-numbers"><code class="language-go">var _ = map[bool]int{false: 0, N>=M: 1}
</code></pre>

<p>
注意：目前， <a href="https://github.com/golang/go/issues/28104">gccgo 8.2.0 有一个bug</a>，就是允许重复的常量键出现在复合字面值中。
因此目前这个技巧不适用于gccgo。这个bug将会在之后的gccgo版本中被修复。
</p>

类似的，断言两个整数常量相等的方法：

<pre class="line-numbers"><code class="language-go">var _ [N-M]int; var _ [M-N]int
type _ [N-M]int; type _ [M-N]int
const _, _ uint = N-M, M-N
func _([N-M]int, [M-N]int) {}

var _ = map[bool]int{false: 0, M==N: 1}

var _ = [1]int{M-N: 0} // the only valid index is 0
var _ = [1]int{}[M-N]  // the only valid index is 0

var _ [N-M]int = [M-N]int{}
</code></pre>

<p>
最后一行的灵感同样来自于Luke Champine的一条tweets。
</p>

如何断言一个常量字符串不是空格。

<pre class="line-numbers"><code class="language-go">type _ [len(aStringConstant)-1]int
var _ = map[bool]int{false: 0, aStringConstant != "": 1}
var _ = aStringConstant[:1]
var _ = aStringConstant[0]
const _ = 1/len(aStringConstant)
</code></pre>

<p>
最后一行借鉴自Jan Mercl的<a href="https://groups.google.com/d/msg/golang-nuts/w1-JQMaH7c4/qzBFSPImBgAJ">点子</a>。
</p>

有时候，为了避免包级别的变量消耗太多的内存，
我们可以把断言代码放在使用空格标识符声明的函数中。
例如，

<pre class="line-numbers"><code class="language-go">func _() {
	var _ = map[bool]int{false: 0, N>=M: 1}
	var _ [N-M]int
}
</code></pre>

</div>



<p class="anchor" id="declare-max-int-uint"></p>
<h3>如何声明一个最大的int和uint常量？</h3>

<div>

<pre class="line-numbers"><code class="language-go">const MaxUint = ^uint(0)
const MaxInt = int(^uint(0) >> 1)
</code></pre>

<p>
</p>

</div>



<p class="anchor" id="detect-word-size-at-compile-time"></p>
<h3>如何在编译时检测原生单词大小？</h3>

<div>

这个技巧和Go无关。

<pre class="line-numbers"><code class="language-go">const Is64bitArch = ^uint(0) >> 63 == 1
const Is32bitArch = ^uint(0) >> 63 == 0
const WordBits = 32 << (^uint(0) >> 63) // 64 or 32
</code></pre>

<p>
</p>

</div>



<p class="anchor" id="64bit-alignment-guarantee"></p>
<h3>如何保证64位原子函数调用的第一个指针参数在32位架构上总是64位对齐的？</h3>

<div>
关于细节请阅读<a href="memory-layout.html">Go值内存布局</a>。
</div>



<p class="anchor" id="avoid-boxing-large-size-values"></p>
<h3>避免将大的值装箱到接口值中。</h3>

<div>
<p>
当一个非接口值被赋值给一个接口值，一个非接口值将被装箱到接口值中。
复制的开销依赖于非接口值的大小。大小越大，复制开销越大。
所以请尽量避免将一个大的值装箱到接口值中。
</p>

在下面的例子中，后两个打印调用的成本要比前两个低得多。

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	var a [1000]int

	// This cost of the two lines is high.
	fmt.Println(a)                   // a is copied
	fmt.Printf("Type of a: %T\n", a) // a is copied

	// The cost of the two lines is low.
	fmt.Printf("%v\n", a[:])
	fmt.Println("Type of a:", fmt.Sprintf("%T", &a)[1:])
}
</code></pre>

<p>
</p>

<p>
关于不同类型值的大小，请阅读<a href="value-copy-cost.html">Go中的值复制开销</a>。
</p>

</div>



<p class="anchor" id="make-use-of-bce"></p>
<h3>使用BCE进行优化（消除边界检查）。</h3>

<div>

<p>
请阅读<a href="bounds-check-elimination.html">这篇文章</a>来获知什么是BCE以及Go目前对BCE的支持有多好。
这篇文章同样展示了一些关于如何使用BCE来做代码优化的例子。
这里提供了另一个例子:

<pre class="line-numbers"><code class="language-go">package main

import (
	"strings"
	"testing"
)

func NumSameBytes_1(x, y string) int {
	if len(x) > len(y) {
		x, y = y, x
	}
	for i := 0; i < len(x); i++ {
		if x[i] != y[i] {
			return i
		}
	}
	return len(x)
}

func NumSameBytes_2(x, y string) int {
	if len(x) > len(y) {
		x, y = y, x
	}
	if len(x) <= len(y) { // more code but more efficient
		for i := 0; i < len(x); i++ {
			if x[i] != y[i] { // bound check eliminated
				return i
			}
		}
	}
	return len(x)
}

var x = strings.Repeat("hello", 100) + " world!"
var y = strings.Repeat("hello", 99) + " world!"

func BenchmarkNumSameBytes_1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = NumSameBytes_1(x, y)
	}
}

func BenchmarkNumSameBytes_2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		_ = NumSameBytes_2(x, y)
	}
}
</code></pre>

在上面的例子里，函数<code>NumSameBytes_2</code>比函数<code>NumSameBytes_1</code>效率更高。
基准测试结果：


<pre class="output"><code>BenchmarkNumSameBytes_1-4   	10000000	       669 ns/op
BenchmarkNumSameBytes_2-4   	20000000	       450 ns/op
</code></pre>


<p>
</p>

<p>
请记住，在每一个主要的标准Go编译器(gc)的发布版里都有一些小的改进。
使用在上述例子中的技巧在Go SDK 1.11之前的版本中不工作。
未来的gc版本可能会变得更加智能，因此这些技巧会变的不再必要。
</p>

</div>


<!--

select{}

how to delcared a new type which will not has the same underlying type with other types.
	type T *T

use named returns, better readibility

define exported error values as constants, or maybe can make using of declared function values

avoid gc too frequently by allocating a large memroy block for a global variable.

try to avoid unnecessary synchronization, for example, make data only be used in one goroutine.
math/rand.NewSource() are faster but not concurrent safe.
but Bytes() method is not fast

try to avoid using large-sized types as
* map key and element types,
* interface dynamic types: don't use string or large size values as error
* channel element types


fmt.Print(v) // values referenced by v escape to heap


sync.Pool, sync.Map

use types without pointer components as container elements would ... the burden of GC.

... GC burdan by reusing values

unnamed types have better readibilities, don't use their alias or types defined from them without sspecial reasons.

use {} to shrink scope of identifiers as needed.
use {} to create a nested block to shadow identifiers declared in outer blocks.

intermediate results should be stored out of the benchmark function

select may slow: https://twitter.com/melvinodsa/status/1031434710184939522

<p class="anchor" id="embed-unexported-alias-of-exported-type"></p>
<h3>Embedding an unexported alias of an exported type to avoiding the corresponding anonymous field being modified in user packages.</h3>


try to share Transport for http.Client values. (need a go practice article)
avoid using the http.Get, ..., functions directly.

  http://stackoverflow.com/questions/17948827/reusing-http-connections-in-golang
  So if you create a new Transport for each request,
  it will create new connections each time.
  In this case the solution is to share the one Transport instance between clients.
  http://stackoverflow.com/questions/36688633/how-to-release-http-client-in-go

  Request.Close
  http://craigwickesser.com/2015/01/golang-http-to-many-open-files/
  https://golang.org/pkg/net/http/#Request
        // For client requests, setting this field prevents re-use of
        // TCP connections between requests to the same hosts, as if
        // Transport.DisableKeepAlives were set.

+setting GOMAXPROCS with a value larger than NumCPUs is good for the performance of a program sometimes^M
+https://news.ycombinator.com/item?id=18350362^

simulate subPackages
	package foo / import "a.b/foo"
	type SubPkg_ struct{}
	var SubPkg SubPkg_
	func (SubPkg_) FunctionX()
	func (SubPkg_) FunctionY()

	package main
	import "a.b/foo"
	func main() {
		foo.SubPkg.FunctionX()
	}

req.WithContext(context.WithValue(req.Context(), paramsKeyType{}, Params{path, tokens})) is slow
https://github.com/golang/go/issues/28737

how to embed an exported type as a non-export field?
so that package users can modify the field.
	type embeddedType = ExportedType

use make() instead of composite literals to initilize map and slice
if the accurate or approiximate number of elements is known.

If the types of some results of a function are identifier,
it would be better to use named results for "code as docs"

manually adjust struct field positions to save memory.


import "sync"
type T struct {
	_ [0]sync.Mutex
}
func main() {
	var t T
	_ = t // go vet: assignment copies lock value to _: main.T contains sync.Mutex
}
-->




